public string NN get VB class NN path NN public string get class path root ROOT get compound path class dobj get path
will children be started automatically when they are added protected boolean start VB children NNS true JJ will children be started automatically when they are added root ROOT started aux started will nsubjpass started children auxpass started be advmod started automatically advmod added when nsubjpass added they auxpass added are advcl started added protected boolean start children root ROOT start dobj start children true added started ANTONYM ANTONYM
sets function name and sets its parent to this node param name function name code null for anonymous functions public void set NN function NN name NN name NN name NN sets function name and sets its parent to this node root ROOT function nsubj function sets nsubj sets sets dobj function name cc function and conj and function sets nmod poss parent its dobj sets parent case node to det node this nmod to sets node param name function name code null for anonymous functions root ROOT null compound null param compound null name compound null function compound null name compound null code case functions for amod functions anonymous nmod for null functions public void set function name root ROOT name compound name set compound name function name name name parent ANTONYM ANTONYM
public name NN get VB function NN name NN public name get function name root ROOT get compound name function dobj get name
private list NN ast IN node NN params NNS private list ast node root ROOT node case node ast params
private boolean is VBZ generator NN private boolean is generator root ROOT generator cop generator is
public boolean is VBZ expression NN closure NN public boolean is expression closure root ROOT closure cop closure is compound closure expression
sets base starting line number for this script or function this is a one time operation and throws an exception if the line number has already been set public void set VBN base NN lineno NN int lineno NN sets base starting line number for this script or function root ROOT number compound number sets compound number base amod number starting compound number line case script for det script this nmod for number script cc script or nmod for number function conj or script function this is a one time operation and throws an exception if the root ROOT operation nsubj operation this nsubj throws this cop operation is det operation a nummod operation one compound operation time cc operation and conj and operation throws det exception an dobj operation exception case the if nmod if exception the line number has already been set root ROOT set compound number line nsubjpass set number aux set has advmod set already auxpass set been public void set base lineno root ROOT set compound lineno base dobj set lineno int lineno base set ANTONYM ANTONYM function operation ANTONYM ANTONYM number function ANTONYM ANTONYM or operation ANTONYM ANTONYM sets base ANTONYM ANTONYM starting function ANTONYM ANTONYM starting has ANTONYM ANTONYM
returns true if the named property is defined as a const on this object param name return true if the named property is defined as a const false otherwise public boolean is VBZ const IN string NN name NN returns true if the named property is defined as a const on this object root ROOT returns amod returns true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const case object on det object this nmod on const object param name root ROOT name compound name param return true if the named property is defined as a const false root ROOT return amod return true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const amod const false otherwise public boolean is const root ROOT const cop const is string name is name ANTONYM ANTONYM named is ANTONYM ANTONYM true false ANTONYM ANTONYM
private int syntax NN error NN count NN private int syntax error count root ROOT count compound count syntax compound count error
public void inject VB authentication NN repository JJ system NN session NN session NN list NN artifact NN repository NN repositories NNS public void inject authentication root ROOT inject dobj inject authentication repository system session root ROOT session amod session repository compound session system session list artifact repository root ROOT repository compound repository artifact repositories
gets the dependencies that could not be resolved return the unresolved dependencies never code null list NN dependency NN get VB unresolved JJ dependencies NNS gets the dependencies that could not be resolved root ROOT gets det dependencies the dobj gets dependencies nsubjpass resolved dependencies ref dependencies that aux resolved could neg resolved not auxpass resolved be acl relcl dependencies resolved return the unresolved dependencies never code null root ROOT return det dependencies the amod dependencies unresolved nsubj code dependencies neg code never ccomp return code dobj code null list dependency get unresolved dependencies root ROOT get amod dependencies unresolved dobj get dependencies gets return ANTONYM ANTONYM resolved unresolved ANTONYM ANTONYM
private maven NN metadata NN cache NN cache NN private maven metadata cache root ROOT cache compound cache maven compound cache metadata cache
nodes NNS incident NN to TO this depend VB on IN me PRP list NN metadata NN graph NN node NN in IN nodes NNS nodes incident to this depend on me list metadata graph node root ROOT node compound node metadata compound node graph in nodes root ROOT nodes case nodes in
public int hash VB code NN public int hash code root ROOT hash dobj hash code
checks the url to see if this repository refers to an external repository param original repository return true if external static boolean is VBZ external JJ repo NN artifact NN repository NN original JJ repository NN checks the url to see if this repository refers to an external repository root ROOT checks det url the dobj checks url mark see to acl to url see mark refers if det repository this nsubj refers repository advcl if see refers case repository to det repository an amod repository external nmod to refers repository param original repository root ROOT repository compound repository param amod repository original return true if external root ROOT return amod return true mark external if advcl if true external static boolean is external repo root ROOT repo cop repo is amod repo external artifact repository root ROOT repository compound repository artifact original repository root ROOT repository amod repository original checks return ANTONYM ANTONYM
public void set VBN global JJ update VBP policy NN string NN update VB policy NN public void set global update policy root ROOT set xcomp set global dep set update dobj update policy string update policy root ROOT update dobj update policy
public void set VBN global JJ checksum NN policy NN string NN checksum NN policy NN public void set global checksum policy root ROOT set amod policy global compound policy checksum dobj set policy string checksum policy root ROOT policy compound policy checksum
private final set NN string NN q VB names NNS new hash JJ set NN private final set string q names root ROOT q dobj q names new hash set root ROOT set amod set hash
public void clear JJ public void clear public clear ANTONYM ANTONYM
first RB element NN of IN the DT queue NN protected entry NN first RB first element of the queue protected entry first
maximum NN size NN of IN the DT queue NN private final int max NN size NN maximum size of the queue private final int max size root ROOT size compound size max
private final entry NN get VB previous JJ private final entry get previous root ROOT get xcomp get previous
final int ord NN final int ord
long fp NN end NN long fp end root ROOT end compound end fp
byte stat NN bytes NNS new byte byte stat bytes root ROOT bytes compound bytes stat new byte
byte floor NN data NNS new byte byte floor data root ROOT data compound data floor new byte
byte suffix NN bytes NNS new byte byte suffix bytes root ROOT bytes compound bytes suffix new byte
int prefix NN int prefix
true JJ if all DT entries NNS are VBP terms NNS boolean is VBZ leaf NN block NN true if all entries are terms boolean is leaf block root ROOT block cop block is compound block leaf
public static final int version NN current JJ public static final int version current root ROOT current compound current version
private int bloom NN size NN private int bloom size root ROOT size compound size bloom
records a value in the set the referenced bytes are hashed and then modulo n d where n is the records a value in the set the referenced bytes are hashed and then modulo n d where n is the chosen size of the internal bitset param value the key value to be hashed throws io exception if there is a low level i o error public void add VB value NN bytes NNS ref VBP value NN throws io NN exception NN records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the chosen size of the internal bitset root ROOT size amod size chosen case bitset of det bitset the amod bitset internal nmod of size bitset param value the key value to be hashed root ROOT value compound value param det value the amod value key dep value value mark hashed to auxpass hashed be acl to value hashed throws io exception if there is a low level i o error root ROOT throws compound exception io dobj throws exception mark is if expl is there advcl if throws is det level a amod level low nsubj is level compound error i compound error o dep level error public void add value root ROOT add dobj add value bytes ref root ROOT ref nsubj ref bytes value throws io exception root ROOT exception compound exception io d key ANTONYM ANTONYM i key ANTONYM ANTONYM level set ANTONYM ANTONYM public internal ANTONYM ANTONYM d i SYNONYM SYNONYM
public long ram NN bytes NNS used VBN public long ram bytes used root ROOT used compound bytes ram nsubj used bytes
public boolean is VBZ saturated VBN fuzzy JJ set NN bloom NN filter NN field NN info NN field NN info NN public boolean is saturated root ROOT saturated auxpass saturated is fuzzy set root ROOT set amod set fuzzy bloom filter root ROOT filter compound filter bloom field info root ROOT info compound info field field info root ROOT info compound info field
public int size NN public int size
public void check NN integrity NN throws io NN exception NN public void check integrity root ROOT integrity compound integrity check throws io exception root ROOT exception compound exception io
private final list NN field NN meta NN data NNS fields NNS new array NN list NN private final list field meta data root ROOT data compound data field compound data meta fields new array list root ROOT list compound list array
reused VBN in IN write VB blocks NNS private final list NN pending VBG block NN new JJ blocks NNS new array NN list NN reused in write blocks root ROOT write dobj write blocks private final list pending block root ROOT block amod block pending new blocks root ROOT blocks amod blocks new new array list root ROOT list compound list array
private pending VBG term NN first RB pending VBG term NN private pending term root ROOT term amod term pending first pending term root ROOT term advmod term first amod term pending
private pending VBG term NN last JJ pending JJ term NN private pending term root ROOT term amod term pending last pending term root ROOT term amod term last amod term pending
public void finish NN doc NN throws io NN exception NN public void finish doc root ROOT doc compound doc finish throws io exception root ROOT exception compound exception io
private long last JJ encoded VBN version NN private long last encoded version root ROOT version amod version last amod version encoded
public void encode VBP term NN long longs NNS data NNS output NN out IN field NN info NN field NN info NN block NN term NN state NN state NN boolean absolute JJ throws io NN exception NN public void encode term root ROOT encode dobj encode term long longs data output root ROOT output compound output data out field info root ROOT info compound info field field info root ROOT info compound info field block term state root ROOT state compound state block compound state term state boolean absolute throws io exception root ROOT exception compound exception io
public boolean has VBZ freqs NNS public boolean has freqs root ROOT has dobj has freqs
override NN public boolean has VBZ offsets NNS override public boolean has offsets root ROOT has dobj has offsets
override NN public boolean has VBZ positions NNS override public boolean has positions root ROOT has dobj has positions
override NN public boolean has VBZ payloads NNS override public boolean has payloads root ROOT has dobj has payloads
public long get VB sum NN total JJ term NN freq NN public long get sum total term freq root ROOT get compound freq sum amod freq total compound freq term dobj get freq
public long get VB sum NN doc NN freq NN public long get sum doc freq root ROOT get compound freq sum compound freq doc dobj get freq
public int get VB doc NN count NN public int get doc count root ROOT get compound count doc dobj get count
public long ram NN bytes NNS used VBN public long ram bytes used root ROOT used compound bytes ram nsubj used bytes
override NN public boolean is VBZ new JJ fragment NN override public boolean is new fragment root ROOT fragment cop fragment is amod fragment new
int frag NN num NN int frag num root ROOT num compound num frag
void set VBN score NN float score NN void set score root ROOT set dobj set score float score
public float get VB score NN public float get score root ROOT get dobj get score
param frag fragment to be merged into this one public void merge VB text NN fragment NN frag NN param frag fragment to be merged into this one root ROOT fragment compound fragment param compound fragment frag mark merged to auxpass merged be acl to fragment merged case one into det one this nmod into merged one public void merge text fragment root ROOT fragment compound fragment text frag merged one SYNONYM SYNONYM
return the fragment sequence number public int get VB frag NN num NN return the fragment sequence number root ROOT return det number the compound number fragment compound number sequence dobj return number public int get frag num root ROOT get compound num frag dobj get num return number ANTONYM ANTONYM
private list NN position NN span NN position NN spans NNS new array NN list NN private list position span root ROOT span compound span position position spans root ROOT spans compound spans position new array list root ROOT list compound list array
public weighted JJ span NN term NN float weight NN string NN term NN boolean position NN sensitive JJ public weighted span term root ROOT term amod term weighted compound term span float weight string term boolean position sensitive root ROOT sensitive nmod npmod sensitive position
checks to see if this term is valid at code position code param position to check against valid term positions return true iff this term is a hit at this position public boolean check NN position NN int position NN checks to see if this term is valid at code position code root ROOT checks mark see to acl to checks see mark valid if det term this nsubj valid term cop valid is advcl if see valid case code at compound code code compound code position nmod at valid code param position root ROOT position compound position param to check against valid term positions root ROOT check mark check to case positions against amod positions valid compound positions term nmod against check positions return true iff this term is a hit at this position root ROOT hit compound term return amod term true advmod term iff det term this nsubj hit term cop hit is det hit a case position at det position this nmod at hit position public boolean check position root ROOT position compound position check int position check hit ANTONYM ANTONYM check return ANTONYM ANTONYM checks hit ANTONYM ANTONYM checks return ANTONYM ANTONYM see hit ANTONYM ANTONYM
public boolean is VBZ position NN sensitive JJ public boolean is position sensitive root ROOT sensitive cop sensitive is nmod npmod sensitive position
public void set VBN position NN sensitive JJ boolean position NN sensitive JJ public void set position sensitive root ROOT set nmod npmod sensitive position xcomp set sensitive boolean position sensitive root ROOT sensitive nmod npmod sensitive position
public list NN position NN span NN get VB position NN spans NNS public list position span root ROOT span compound span position get position spans root ROOT get compound spans position dobj get spans
returns NNS the DT total NN number NN of IN tokens NNS for this field NN see terms get sum total term freq public final long sum NN total JJ term NN freq NN returns the total number of tokens for this field see terms get sum total term freq root ROOT see nsubj get terms ccomp see get compound freq sum amod freq total compound freq term dobj get freq public final long sum total term freq root ROOT freq compound freq sum amod freq total compound freq term returns number ANTONYM ANTONYM total final ANTONYM ANTONYM
returns NNS the DT total NN number NN of IN postings NNS for this field NN see terms get sum doc freq public final long sum NN doc NN freq NN returns the total number of postings for this field see terms get sum doc freq root ROOT see nsubj get terms ccomp see get compound freq sum compound freq doc dobj get freq public final long sum doc freq root ROOT freq compound freq sum compound freq doc returns number ANTONYM ANTONYM total final ANTONYM ANTONYM
private final disi NN priority NN queue NN sub NN scorers NNS private final disi priority queue root ROOT queue compound queue disi compound queue priority sub scorers root ROOT scorers compound scorers sub
public int compare VB bottom NN int doc NN throws io NN exception NN public int compare bottom root ROOT compare dobj compare bottom int doc throws io exception root ROOT exception compound exception io
public void set VBN bottom NN final int bottom NN public void set bottom root ROOT set dobj set bottom final int bottom
public term NN get VB term NN public term get term root ROOT get dobj get term
public mutable JJ value NN duplicate VB public mutable value root ROOT value amod value mutable duplicate
public static double to TO degrees NNS final double radians NNS public static double to degrees root ROOT degrees case degrees to final double radians
This method NN returns NNS the DT internal JJ heap NN array NN as IN object NN protected final object NN get VB heap NN array NN This method returns the internal heap array as object protected final object get heap array root ROOT get compound array heap dobj get array
public void set VBN max NN int limit NN public void set max root ROOT set dobj set max int limit
public static final storage NN level NN none NN create VB false JJ false JJ false JJ false JJ public static final storage level root ROOT level compound level storage none create false false false false
public static final storage NN level NN memory NN only RB create VB false JJ true JJ false JJ true JJ public static final storage level root ROOT level compound level storage memory only root ROOT memory advmod memory only create false true false true false true ANTONYM ANTONYM
public static storage NN level NN create VB boolean use NN disk NN boolean use NN memory NN boolean use VB off RP heap NN boolean deserialized VBN int replication NN public static storage level root ROOT level compound level storage create boolean use disk root ROOT disk compound disk use boolean use memory root ROOT memory compound memory use boolean use off heap root ROOT use compound prt use off dobj use heap boolean deserialized int replication
public int compare VB long b NN long a DT public int compare long b long a
public int compare VB long a DT prefix NN long b NN prefix NN public int compare long a prefix root ROOT prefix det prefix a long b prefix root ROOT prefix compound prefix b
private final long num NN elements NNS for IN spill NN threshold NN private final long num elements for spill threshold root ROOT elements compound elements num case threshold for compound threshold spill nmod for elements threshold
private final linked VBN list NN memory NN block NN allocated VBN pages NNS new linked VBN list NN private final linked list root ROOT list amod list linked memory block root ROOT block compound block memory allocated pages root ROOT pages amod pages allocated new linked list root ROOT list amod list linked
private final linked VBN list NN unsafe JJ sorter NN spill NN writer NN spill NN writers NNS new linked VBN list NN private final linked list root ROOT list amod list linked unsafe sorter spill writer root ROOT writer amod writer unsafe compound writer sorter compound writer spill spill writers root ROOT writers compound writers spill new linked list root ROOT list amod list linked
return the total number of bytes that has been spilled into disk so far public long get VB spill NN size NN return the total number of bytes that has been spilled into disk so far root ROOT return det number the amod number total dobj return number case bytes of nmod of number bytes nsubjpass spilled bytes ref bytes that aux spilled has auxpass spilled been acl relcl bytes spilled case disk into nmod into spilled disk advmod far so advmod spilled far public long get spill size root ROOT get compound size spill dobj get size return has ANTONYM ANTONYM return number ANTONYM ANTONYM
free this sorter s data pages return the number of bytes freed private long free JJ memory NN free this sorter s data pages root ROOT pages amod pages free det sorter this compound pages sorter compound pages s compound pages data return the number of bytes freed root ROOT return det number the dobj return number case bytes of nmod of number bytes acl number freed private long free memory root ROOT memory amod memory free return number ANTONYM ANTONYM
public int get VB num NN records NNS public int get num records root ROOT get compound records num dobj get records
public boolean has VBZ next JJ public boolean has next root ROOT has advmod has next
public int get VB record NN length NN public int get record length root ROOT get compound length record dobj get length
private final prefix NN comparator NN prefix NN comparator NN private final prefix comparator root ROOT comparator compound comparator prefix prefix comparator root ROOT comparator compound comparator prefix
marks the current page as no more space available and as a result either allocate a new page or spill when we see the next record visible JJ for IN testing NN public void close RB current JJ page NN marks the current page as no more space available and as a result either allocate a root ROOT marks det page the amod page current dobj marks page case space as neg space no amod space more nmod as marks space amod space available cc marks and case result as det result a conj and marks result cc preconj allocate either acl result allocate dobj allocate a new page or spill when we see the next record root ROOT page amod page new cc page or conj or page spill advmod see when nsubj see we acl relcl page see det record the amod record next dobj see record visible for testing root ROOT visible case testing for nmod for visible testing public void close current page root ROOT page amod page close amod page current marks record ANTONYM ANTONYM marks see ANTONYM ANTONYM
private void update VB peak NN memory NN used VBN private void update peak memory used root ROOT update compound memory peak dobj update memory acl memory used
private static void sort NN key JJ prefix NN array NN at IN byte NN long RB array NN array NN long num NN records NNS long counts NNS int byte NN idx NN long in IN index NN long out IN index NN boolean desc NN boolean signed VBN private static void sort key prefix array at byte root ROOT array compound array sort amod array key compound array prefix case byte at nmod at array byte long array root ROOT array advmod array long array long num records root ROOT records compound records num long counts int byte idx root ROOT idx compound idx byte long in index root ROOT index case index in long out index root ROOT index case index out boolean desc boolean signed
public void write VB byte b NN int off IN int len NN throws io NN exception NN public void write byte b int off int len throws io exception root ROOT exception compound exception io
private string NN filename NN private string filename
private print NN stream NN output NN stream NN private print stream root ROOT stream compound stream print output stream root ROOT stream compound stream output
public file NN stream NN sink NN task NN print NN stream NN output NN stream NN public file stream sink task root ROOT task compound task file compound task stream compound task sink print stream root ROOT stream compound stream print output stream root ROOT stream compound stream output
public void start NN map NN string NN string NN props NNS public void start map string string props
private void set VBN timeout NN private void set timeout root ROOT set dobj set timeout
public void stop VB public void stop
public static final long default NN failure NN delay NN ms NNS public static final long default failure delay ms root ROOT ms compound ms default compound ms failure compound ms delay
private static final logger NN log NN logger NN factory NN get VB logger NN MockConnector class private static final logger log logger factory get logger root ROOT get compound factory logger nsubj get factory dobj get logger MockConnector class
final string NN transformation NN name NN final string transformation name root ROOT name compound name transformation
private doc NN info NN string NN transformation NN name NN string NN overview NN config NN def NN config NN def NN private doc info root ROOT info compound info doc string transformation name root ROOT name compound name transformation string overview config def root ROOT def compound def config config def root ROOT def compound def config
private static void print NN transformation NN html NN print NN stream NN out IN doc NN info NN doc NN info NN private static void print transformation html root ROOT html compound html print compound html transformation print stream root ROOT stream compound stream print out doc info root ROOT info compound info doc doc info root ROOT info compound info doc
private static void print NN html NN print NN stream NN out IN throws no DT such JJ field NN exception NN illegal JJ access NN exception NN instantiation NN exception NN private static void print html root ROOT html compound html print print stream root ROOT stream compound stream print out throws no such field exception root ROOT field neg field no amod field such dep field exception illegal access exception root ROOT exception amod exception illegal compound exception access instantiation exception root ROOT exception compound exception instantiation
public static void main JJ string NN args NNS throws exception NN public static void main string args throws exception
public config NN def NN config NN public config def root ROOT def compound def config config
public offset VBN storage NN reader NN offset VBN storage NN reader NN public offset storage reader root ROOT reader amod reader offset compound reader storage offset storage reader root ROOT reader amod reader offset compound reader storage
private final offset VBN storage NN reader NN reader NN private final offset storage reader root ROOT reader amod reader offset compound reader storage reader
protected final class NN loader NN loader NN protected final class loader root ROOT loader compound loader class loader
protected final connector NN task NN id NN id NN protected final connector task id root ROOT id compound id connector compound id task id
private volatile target NN state NN target NN state NN private volatile target state root ROOT state compound state target target state root ROOT state compound state target
cancel this task this won t actually stop it but it will prevent the state from being cancel this task this won t actually stop it but it will prevent the state from being updated when it eventually does shutdown public void cancel VB cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being updated when it eventually does shutdown root ROOT updated advmod does when nsubj does it advmod does eventually advcl updated does dobj does shutdown public void cancel cancel void ANTONYM ANTONYM stop shutdown ANTONYM ANTONYM
public pane NN info NN tracker NN timer NN internals NNS timer NN internals NNS public pane info tracker root ROOT tracker compound tracker pane compound tracker info timer internals root ROOT internals compound internals timer timer internals root ROOT internals compound internals timer
public boolean is VBZ empty JJ public boolean is empty root ROOT empty cop empty is
private set NN p NN collection NN view NN views NNS private set p collection view root ROOT view compound view p compound view collection views
public void delete VB timer NN instant NN timestamp NN time NN domain NN time NN domain NN public void delete timer root ROOT delete dobj delete timer instant timestamp time domain root ROOT domain compound domain time time domain root ROOT domain compound domain time
public void set VBN timer NN instant NN timestamp NN time NN domain NN time NN domain NN public void set timer root ROOT set dobj set timer instant timestamp time domain root ROOT domain compound domain time time domain root ROOT domain compound domain time
protected final active JJ window NN set NN w NN active JJ windows NNS protected final active window set root ROOT set amod set active compound set window w active windows root ROOT windows amod windows active
protected final state NN context NN w NN context NN protected final state context root ROOT context compound context state w context
protected final state NN internals NNS state NN internals NNS protected final state internals root ROOT internals compound internals state state internals root ROOT internals compound internals state
public k NN key NN public k key k key ANTONYM ANTONYM
add an end of window hold or if too late for that a garbage collection hold if required return the link instant at which hold was added or literal null if no hold was added nullable JJ private instant NN add VB end NN of IN window NN or CC garbage NN collection NN holds VBZ reduce VB fn NN w NN context NN context NN boolean pane NN is VBZ empty JJ add an end of window hold or if too late for that a garbage collection hold if required root ROOT add det end an dobj add end case hold of compound hold window nmod of end hold cc add or case late if advmod late too conj or add late mark hold for mark hold that det collection a compound collection garbage nsubj hold collection dep late hold mark required if advcl if hold required return the link instant at which hold was added or literal null if no hold was added root ROOT return det instant the compound instant link dobj return instant nmod at added instant case which at ref instant which aux added hold auxpass added was acl relcl instant added cc added or amod null literal acl relcl instant null conj or added null mark added if neg hold no nsubjpass added hold auxpass added was dep added added nullable private instant add end of window or garbage collection holds root ROOT holds csubj holds add dobj add end case window of nmod of end window cc window or compound collection garbage nmod of end collection conj or window collection reduce fn root ROOT reduce dobj reduce fn w context context boolean pane is empty root ROOT empty nsubj empty pane cop empty is hold required ANTONYM ANTONYM hold return ANTONYM ANTONYM
public void prefetch NN on IN merge VBP merging VBG state NN accessor NN w NN state NN public void prefetch on merge root ROOT merge nsubj merge prefetch acl prefetch on merging state accessor root ROOT merging compound accessor state dobj merging accessor w state
public string NN string NN key NN public string string key root ROOT key compound key string
public boolean equals VBZ object NN obj NN public boolean equals object obj
public int hash VB code NN public int hash code root ROOT hash dobj hash code
public string NN to TO string VB public string to string root ROOT string mark string to
private static final string NN window NN format NN s NNS private static final string window format root ROOT format compound format window s
public w NN get VB window NN public w get window root ROOT get dobj get window
private final duration NN allowed VBN lateness NN private final duration allowed lateness root ROOT allowed dobj allowed lateness
private final boolean observes VBZ window NN private final boolean observes window root ROOT observes dobj observes window
private final side NN input NN reader NN side NN input NN reader NN private final side input reader root ROOT reader compound reader side compound reader input side input reader root ROOT reader compound reader side compound reader input
the DT set NN of IN known VBN output NN tags NNS private final set NN tuple NN tag NN output NN tags NNS the set of known output tags private final set tuple tag root ROOT tag compound tag tuple output tags root ROOT tags compound tags output set tags ANTONYM ANTONYM
public void start VB bundle NN public void start bundle root ROOT start dobj start bundle
public void process NN element NN windowed JJ value NN input NN t NN compressed VBN elem NN public void process element root ROOT element compound element process windowed value root ROOT value amod value windowed input t root ROOT t compound t input compressed elem root ROOT elem amod elem compressed
public pipeline NN options NNS get VB pipeline NN options NNS public pipeline options root ROOT options compound options pipeline get pipeline options root ROOT get compound options pipeline dobj get options
public bounded VBN window NN window NN public bounded window root ROOT window amod window bounded window
public void output NN output NN t NN output NN public void output output t root ROOT t compound t output output
public state NN state NN string NN state NN id NN public state state string state id root ROOT id compound id state
the state namespace for this context p any call to this method when more than one window is present will crash this represents a bug in the runner or the link do fn signature since values must be in exactly one window when state or timers are relevant private state NN namespace NN get VB namespace NN the state namespace for this context root ROOT namespace det namespace the compound namespace state case context for det context this nmod for namespace context p any call to this method when more than one window is present will crash this root ROOT crash dep crash p det call any nsubj crash call case method to det method this nmod to call method advmod present when advmod one more mwe more than nummod window one nsubj present window cop present is acl relcl call present aux crash will dobj crash this represents a bug in the runner or the link do fn signature since values must be in exactly root ROOT represents det bug a dobj represents bug case runner in det runner the nmod in bug runner cc runner or det link the nmod in bug link conj or runner link dep represents do compound signature fn dobj do signature mark exactly since nsubj exactly values aux exactly must cop exactly be case exactly in advcl since do exactly one window when state or timers are relevant root ROOT window nummod window one advmod relevant when nsubj relevant state cc state or conj or state timers nsubj relevant timers cop relevant are acl relcl window relevant private state namespace root ROOT namespace compound namespace state get namespace root ROOT get dobj get namespace is present ANTONYM ANTONYM state present ANTONYM ANTONYM
private duration NN period NN duration NN zero CD private duration period duration zero root ROOT duration nummod duration zero
private duration NN offset VBN duration NN zero CD private duration offset duration zero root ROOT duration nummod duration zero
override NN public void set NN relative JJ override public void set relative root ROOT set dep set relative
sets the timer for the target time without checking anything about whether it is a reasonable thing to do for example absolute processing time timers are not a reasonable thing to do for example absolute processing time timers are not really sensible since the user has no way to compute a good choice of time private void set VBN underlying VBG timer NN instant NN target NN sets the timer for the target time without checking anything about whether it is root ROOT sets det timer the dobj sets timer case time for det time the compound time target nmod for timer time mark checking without advcl without sets checking dobj checking anything mark is about mark is whether nsubj is it acl whether anything is a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not really sensible since the user has no way to compute a good choice of time root ROOT sensible advmod sensible really mark has since det user the nsubj has user advcl since sensible has neg way no dobj has way mark compute to acl to way compute det choice a amod choice good dobj compute choice case time of nmod of choice time private void set underlying timer root ROOT set xcomp set underlying dobj underlying timer instant target checking has ANTONYM ANTONYM do has ANTONYM ANTONYM do processing ANTONYM ANTONYM reasonable good ANTONYM ANTONYM sensible good ANTONYM ANTONYM sets checking ANTONYM ANTONYM sets target ANTONYM ANTONYM void good ANTONYM ANTONYM absolute good SYNONYM SYNONYM
public peeking VBG reiterator NN reiterator NN t NN iterator NN public peeking reiterator root ROOT peeking dobj peeking reiterator reiterator t iterator
public t NN next IN public t next
private void compute VB next IN private void compute next root ROOT compute advmod compute next
private final metric JJ name NN name NN private final metric name root ROOT name amod name metric name
public metric JJ name NN get VB name NN public metric name root ROOT name amod name metric get name root ROOT get dobj get name
public dirty JJ state NN get VB dirty JJ public dirty state root ROOT state amod state dirty get dirty root ROOT get xcomp get dirty
internal JJ public distribution NN cell NN metric JJ name NN name NN internal public distribution cell root ROOT cell compound cell distribution metric name root ROOT name amod name metric name
public iterable JJ t NN values NNS public iterable t values
abstract read VB k NN v LS build VB abstract read k v build k v SYNONYM SYNONYM
public configuration NN get VB public configuration get
public serializable JJ configuration NN configuration NN conf NN public serializable configuration root ROOT configuration amod configuration serializable configuration conf
private transient configuration NN conf NN private transient configuration conf
private static final long serial JJ version NN uid NN l NN private static final long serial version uid root ROOT uid amod uid serial compound uid version l
private static final string NN default NN appname NN beam NN gearpump NN app NN private static final string default appname root ROOT appname compound appname default beam gearpump app root ROOT app compound app beam compound app gearpump
protected string NN result NN path NN protected string result path root ROOT path compound path result
private final instant NN offset VBN private final instant offset
public string NN to TO string VB public string to string root ROOT string mark string to
public delay NN fn NN duration NN delay NN public delay fn root ROOT fn compound fn delay duration delay
public void clear JJ trigger NN context NN c NN throws exception NN public void clear trigger context root ROOT context compound context trigger c throws exception clear throws ANTONYM ANTONYM public clear ANTONYM ANTONYM
w NN write VB state NN address NN w NN window NN w write state address root ROOT write compound address state dobj write address w window
private in IN memory NN timer NN internals NNS timer NN internals NNS private in memory timer internals root ROOT internals case internals in compound internals memory compound internals timer timer internals root ROOT internals compound internals timer
public void close RB throws exception NN public void close throws exception public close ANTONYM ANTONYM
private final metric JJ update VBP t NN committed VBN private final metric update root ROOT update nsubj update metric t committed
public string NN step NN public string step
private accumulated VBN metric JJ result NN metric JJ name NN name NN string NN step NN t NN attempted VBN t NN committed VBN boolean is VBZ committed VBN supported VBN private accumulated metric result root ROOT result amod result accumulated amod result metric metric name root ROOT name amod name metric name string step t attempted t committed boolean is committed supported root ROOT committed auxpass committed is dep committed supported
public iterable JJ map NN entry NN k NN t NN entries NNS public iterable map entry root ROOT entry compound entry map k t entries
Transient fields NNS that IN are VBP lazy JJ initialized VBN and CC then RB memoized VBN private transient extension NN registry NN memoized JJ extension NN registry NN Transient fields that are lazy initialized and then memoized private transient extension registry root ROOT registry compound registry extension memoized extension registry root ROOT registry amod registry memoized compound registry extension
static final type NN descriptor NN message NN message NN type NN new type NN descriptor NN message NN static final type descriptor root ROOT descriptor compound descriptor type message message type root ROOT type compound type message new type descriptor root ROOT descriptor compound descriptor type message
public set NN Class get VB extension NN hosts NNS public set Class get extension hosts root ROOT get compound hosts extension dobj get hosts
public object NN to TO object VB public object to object root ROOT object mark object to
public int value NN public int value
public final int doc NN id NN public final int doc id root ROOT id compound id doc
private final disjunction NN disi NN approximation NN approximation NN private final disjunction disi approximation root ROOT approximation compound approximation disjunction compound approximation disi approximation
escape NN character NN public static final char wildcard NN escape NN escape character public static final char wildcard escape root ROOT escape compound escape wildcard
starting VBG term NN ord NN for this frame NN used VBN to TO reset VB term NN ord NN in IN rewind NN long term NN ord NN orig NN starting term ord root ROOT ord compound ord term for this frame used to reset term ord root ROOT ord compound ord term in rewind long term ord orig root ROOT orig compound orig term compound orig ord
placeholder NN for missing VBG offset VBN that IN means NNS all DT values NNS are VBP missing VBG static final int all DT missing VBG placeholder for missing offset that means all values are missing static final int all missing root ROOT missing dep missing all
static final int sorted VBN single JJ valued VBN static final int sorted single valued root ROOT sorted xcomp sorted single dep single valued
build VB reverse NN index NN from IN every DT th DT term NN static final int reverse JJ interval NN shift NN build reverse index from every th term static final int reverse interval shift root ROOT shift amod shift reverse compound shift interval
final int stack VB final int stack
public terms NNS enum VBP with IN slice NN int index NN reader NN slice NN sub NN slice NN public terms enum with slice root ROOT enum nsubj enum terms case slice with nmod with enum slice int index reader slice root ROOT slice compound slice reader sub slice root ROOT slice compound slice sub
Default maximum NN number NN of IN point NN in IN each DT leaf NN block NN public static final int default NN max NN points NNS in IN leaf NN node NN Default maximum number of point in each leaf block public static final int default max points in leaf node root ROOT points compound points default compound points max case node in compound node leaf nmod in points node block points ANTONYM ANTONYM point block ANTONYM ANTONYM
private final int bytes NNS per IN doc NN private final int bytes per doc root ROOT bytes case doc per nmod per bytes doc
writes VBZ the DT bkd NN tree NN to TO the DT provided VBN writes the bkd tree to the provided
private term NN iterator NN iterator NN private term iterator root ROOT iterator compound iterator term iterator
public void visit NN int doc NN id NN public void visit int doc id root ROOT id compound id doc
Public final boolean equals VBZ object NN other JJ Public final boolean equals object other
byte point NN bytes NNS new byte bytes NNS per IN dim NN byte point bytes root ROOT bytes compound bytes point new byte bytes per dim root ROOT bytes case dim per nmod per bytes dim
private boolean is VBZ wildcard NN char NN sequence NN text NN private boolean is wildcard root ROOT wildcard cop wildcard is char sequence root ROOT sequence compound sequence char text
public double JJ metaphone NN filter NN create VB token JJ stream NN input NN public double metaphone filter root ROOT filter amod filter double compound filter metaphone create token stream root ROOT stream amod stream token input
creates VBZ a DT new double JJ metaphone NN filter NN factory NN public double JJ metaphone NN filter NN factory NN map NN string NN string NN args NNS creates a new double metaphone filter factory root ROOT factory amod factory double compound factory metaphone compound factory filter public double metaphone filter factory root ROOT factory amod factory double compound factory metaphone compound factory filter map string string args
protected void initialize VB iterator NN throws io NN exception NN protected void initialize iterator root ROOT initialize dobj initialize iterator throws io exception root ROOT exception compound exception io
private int final JJ offset VBN private int final offset root ROOT offset advmod offset final
private final offset VBN attribute NN offset VBN attr NN private final offset attribute root ROOT attribute amod attribute offset offset attr root ROOT offset dobj offset attr
private final char NN term NN attribute NN term NN attr NN private final char term attribute root ROOT attribute compound attribute char compound attribute term term attr root ROOT attr compound attr term
the DT list NN of IN holes NNS If a DT point NN is VBZ in IN the DT hole NN it PRP is VBZ not RB in IN the DT polygon NN protected final list NN geo NN polygon NN holes NNS the list of holes If a point is in the hole it is not in the polygon protected final list geo polygon root ROOT polygon compound polygon geo holes
the DT list NN of IN polygon NN points NNS protected final list NN geo NN point NN points NNS the list of polygon points protected final list geo point root ROOT point compound point geo points
check NN if a DT point NN is VBZ within IN the DT provided VBN holes NNS param point point to check return true if the point is within any of the holes protected boolean is VBZ within IN holes NNS final geo NN point NN point NN check if a point is within the provided holes param point point to check root ROOT point compound point param compound point point mark check to acl to point check return true if the point is within any of the holes root ROOT return amod return true mark any if det point the nsubj any point cop any is case any within advcl within true any case holes of det holes the nmod of any holes protected boolean is within holes root ROOT holes cop holes is case holes within final geo point root ROOT point compound point geo point check point ANTONYM ANTONYM check return ANTONYM ANTONYM provided return ANTONYM ANTONYM
protected boolean local JJ is VBZ within IN final vector NN v LS protected boolean local is within root ROOT within nsubj within local cop within is final vector v
public geo NN point NN get VB edge NN points NNS public geo point root ROOT point compound point geo get edge points root ROOT get compound points edge dobj get points
public string NN to TO string VB public string to string root ROOT string mark string to
private static final string NN brokers NNS key JJ name NN brokers NNS private static final string brokers key name root ROOT name compound name brokers amod name key brokers
public metadata NN response NN int throttle NN time NN ms NNS list NN node NN brokers NNS string NN cluster NN id NN int controller NN id NN list NN topic NN metadata NN topic NN metadata NN public metadata response root ROOT response compound response metadata int throttle time ms root ROOT ms compound ms throttle compound ms time list node brokers string cluster id root ROOT id compound id cluster int controller id root ROOT id compound id controller list topic metadata root ROOT metadata compound metadata topic topic metadata root ROOT metadata compound metadata topic
public list NN acl NN creation NN acl NN creations NNS public list acl creation root ROOT creation compound creation acl acl creations root ROOT creations compound creations acl
private static final long commit VB interval NN ms NNS l NN private static final long commit interval ms root ROOT commit compound ms interval dobj commit ms l
private int next JJ timeout NN ms NNS private int next timeout ms root ROOT ms amod ms next compound ms timeout
check for calls which have timed out timed out calls will be removed and failed the remaining milliseconds until the next timeout will be updated param calls the collection of calls return the number of calls which were timed out int handle VB timeouts NNS collection NN call NN calls NNS string NN msg NN check for calls which have timed out root ROOT check case calls for nmod for check calls nsubj timed calls ref calls which aux timed have acl relcl calls timed compound prt timed out timed out calls will be removed and failed root ROOT removed amod calls timed compound prt timed out nsubjpass removed calls nsubjpass failed calls aux removed will auxpass removed be cc removed and conj and removed failed the remaining milliseconds until the next timeout will be updated root ROOT milliseconds det milliseconds the amod milliseconds remaining mark updated until det timeout the amod timeout next nsubjpass updated timeout aux updated will auxpass updated be dep milliseconds updated param calls the collection of calls root ROOT calls nsubj calls param det collection the dobj calls collection case calls of nmod of collection calls return the number of calls which were timed out root ROOT return det number the dobj return number case calls of nmod of number calls nsubjpass timed calls ref calls which auxpass timed were acl relcl calls timed compound prt timed out int handle timeouts root ROOT handle dobj handle timeouts collection call calls string msg check failed ANTONYM ANTONYM check have ANTONYM ANTONYM check return ANTONYM ANTONYM failed return ANTONYM ANTONYM have removed ANTONYM ANTONYM have return ANTONYM ANTONYM next removed ANTONYM ANTONYM return number ANTONYM ANTONYM out failed SYNONYM SYNONYM
private resource NN config NN resource NN to TO resource NN config NN resource NN config NN resource NN private resource config resource to resource root ROOT resource compound resource config case resource to nmod to resource resource config resource root ROOT resource compound resource config config resource root ROOT resource compound resource config
create a self signed x certificate from http bfo com blog odds and ends creating a new x certificate html param dn the x distinguished name eg cn test l london c gb param pair the key pair param days how many days from now the certificate is valid for param algorithm the signing algorithm eg sha with rsa return the self signed certificate throws certificate exception thrown if a security error or an io error occurred public static x CC certificate NN generate VB certificate NN string NN dn NN key JJ pair NN pair NN int days NNS string NN algorithm NN throws certificate NN exception NN create a self signed x certificate root ROOT create det self a nsubj signed self ccomp create signed cc signed x ccomp create certificate conj x signed certificate from http bfo com blog odds and ends creating a new x certificate html root ROOT odds case odds from amod odds http compound odds bfo compound odds com compound odds blog cc odds and aux creating ends conj and odds creating det html a amod html new compound html x compound html certificate dobj creating html param dn the x distinguished name eg cn test l london c gb root ROOT dn nsubj dn param det x the dobj dn x amod name distinguished dep x name compound gb eg compound gb cn compound gb test compound gb l compound gb london compound gb c dep name gb param pair the key pair root ROOT pair compound pair param det pair the amod pair key dep pair pair param days how many days from now the certificate is valid for root ROOT days compound days param advmod many how amod days many dobj valid days case now from nmod from valid now det certificate the nsubj valid certificate cop valid is dep days valid dep valid for param algorithm the signing algorithm eg sha with rsa root ROOT algorithm compound algorithm param det algorithm the compound algorithm signing nsubj sha algorithm advmod sha eg acl relcl algorithm sha case rsa with nmod with sha rsa return the self signed certificate root ROOT signed csubj signed return det self the dobj return self dobj signed certificate throws certificate exception thrown if a security error or an io error occurred root ROOT throws compound exception certificate dobj throws exception acl exception thrown mark occurred if det error a compound error security nsubj occurred error cc error or det error an compound error io conj or error error nsubj occurred error advcl if thrown occurred public static x certificate root ROOT certificate compound certificate x generate certificate root ROOT generate dobj generate certificate string dn key pair root ROOT pair amod pair key pair int days string algorithm throws certificate exception root ROOT exception compound exception certificate create name ANTONYM ANTONYM create thrown ANTONYM ANTONYM create throws ANTONYM ANTONYM creating name ANTONYM ANTONYM creating thrown ANTONYM ANTONYM creating throws ANTONYM ANTONYM distinguished signing ANTONYM ANTONYM name is ANTONYM ANTONYM name thrown ANTONYM ANTONYM name throws ANTONYM ANTONYM return occurred ANTONYM ANTONYM return thrown ANTONYM ANTONYM return throws ANTONYM ANTONYM signed distinguished ANTONYM ANTONYM l c SYNONYM SYNONYM x c SYNONYM SYNONYM x l SYNONYM SYNONYM
public static final type NN nullable JJ string NN new type NN public static final type nullable string root ROOT string amod string nullable new type
public Long validate VB object NN item NN public Long validate object item
public Long read VB byte NN buffer NN buffer NN public Long read byte buffer root ROOT buffer compound buffer byte buffer
public integer NN validate VB object NN item NN public integer validate object item
public boolean has VBZ undrained VBN public boolean has undrained root ROOT undrained aux undrained has
boolean flush NN in IN progress NN boolean flush in progress root ROOT flush case progress in nmod in flush progress
void abort VB undrained JJ batches NNS runtime NN exception NN reason NN void abort undrained batches root ROOT abort amod batches undrained dobj abort batches runtime exception root ROOT exception compound exception runtime reason
close this accumulator and force all the record buffers to be drained public void close RB close this accumulator and force all the record buffers to be drained root ROOT accumulator advmod accumulator close det accumulator this cc accumulator and conj and accumulator force det predet buffers all det buffers the compound buffers record dobj force buffers nsubjpass xsubj drained buffers mark drained to auxpass drained be xcomp force drained public void close close public ANTONYM ANTONYM
disconnects the connection to a particular node if there is one any pending client requests for this connection will receive disconnections param node id the id of the node override NN public void disconnect VB string NN node NN id NN disconnects the connection to a particular node if there is one root ROOT disconnects det connection the dobj disconnects connection case node to det node a amod node particular nmod to connection node mark is if expl is there advcl if disconnects is nsubj is one any pending client requests for this connection will receive disconnections root ROOT receive det requests any amod requests pending compound requests client nsubj receive requests case connection for det connection this nmod for requests connection aux receive will dobj receive disconnections param node id the id of the node root ROOT id compound node param nsubj id node det id the dobj id id case node of det node the nmod of id node override public void disconnect string node id root ROOT id compound id node connection disconnect ANTONYM ANTONYM connection disconnections ANTONYM ANTONYM connection disconnects ANTONYM ANTONYM
closes the connection to a particular node if there is one all requests on the connection will be cleared client request callbacks will not be invoked all requests on the connection will be cleared client request callbacks will not be invoked for the cleared requests nor will they be returned from poll param node id the id of the node override NN public void close RB string NN node NN id NN closes the connection to a particular node if there is one root ROOT closes det connection the dobj closes connection case node to det node a amod node particular nmod to connection node mark is if expl is there advcl if closes is nsubj is one all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked for the cleared requests nor will they be returned from poll root ROOT requests case requests for det requests the amod requests cleared cc requests nor aux returned will nsubjpass returned they auxpass returned be conj nor requests returned case poll from nmod from returned poll param node id the id of the node root ROOT id compound node param nsubj id node det id the dobj id id case node of det node the nmod of id node override public void close string node id root ROOT id compound id node cleared returned ANTONYM ANTONYM public close ANTONYM ANTONYM particular close SYNONYM SYNONYM
check if the node with the given id is ready to send more requests param node the node param now the current time in ms return true if the node is ready override NN public boolean is VBZ ready JJ node NN node NN long now RB check if the node with the given id is ready to send more requests root ROOT check mark ready if det node the nsubj ready node nsubj xsubj send node case id with det id the amod id given nmod with node id cop ready is advcl if check ready mark send to xcomp ready send amod requests more dobj send requests param node the node root ROOT node compound node param det node the dep node node param now the current time in ms root ROOT time nsubj time param advmod time now det time the amod time current case ms in nmod in time ms return true if the node is ready root ROOT return amod return true mark ready if det node the nsubj ready node cop ready is advcl if true ready override public boolean is ready root ROOT ready cop ready is node node long now check given ANTONYM ANTONYM check return ANTONYM ANTONYM given ready ANTONYM ANTONYM given send ANTONYM ANTONYM
queue up the given request for sending requests can only be sent out to ready nodes queue up the given request for sending requests can only be sent out to ready nodes param request the request param now the current timestamp override NN public void send VB client NN request NN request NN long now RB queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes param request the request root ROOT request compound request param det request the dobj request request param now the current timestamp root ROOT timestamp compound timestamp param advmod timestamp now det timestamp the amod timestamp current override public void send client request root ROOT request compound request client request long now given ready ANTONYM ANTONYM given send ANTONYM ANTONYM given sending ANTONYM ANTONYM given sent ANTONYM ANTONYM up ready SYNONYM SYNONYM
handle any disconnected connections param responses the list of responses that completed with the disconnection param now the current time private void handle VB disconnections NNS list NN client NN response NN responses NNS long now RB handle any disconnected connections root ROOT handle det connections any amod connections disconnected dobj handle connections param responses the list of responses that completed with the disconnection root ROOT responses compound responses param det list the dep responses list case responses of nmod of list responses nsubj completed responses ref responses that acl relcl responses completed case disconnection with det disconnection the nmod with completed disconnection param now the current time root ROOT time nsubj time param advmod time now det time the amod time current private void handle disconnections root ROOT handle dobj handle disconnections list client response root ROOT response compound response client responses long now connections disconnection ANTONYM ANTONYM
public isolation NN level NN isolation NN level NN public isolation level root ROOT level compound level isolation isolation level root ROOT level compound level isolation
request NN and CC partition NN level NN name NN private static final string NN max NN bytes NNS key JJ name NN max NN bytes NNS request and partition level name private static final string max bytes key name root ROOT name compound name max compound name bytes amod name key max bytes root ROOT bytes compound bytes max
partition NN level NN field NN names NNS private static final string NN partition NN key JJ name NN partition NN partition level field names private static final string partition key name root ROOT name compound name partition amod name key partition
public partition NN data NNS long fetch VB offset VBN long log NN start NN offset VBP int max NN bytes NNS public partition data root ROOT data compound data partition long fetch offset root ROOT fetch dep fetch offset long log start offset root ROOT offset compound start log nsubj offset start int max bytes root ROOT bytes compound bytes max
private k NN stream NN builder NN setup NN topology NN with IN intermediate JJ user NN topic NN final string NN output NN topic NN private k stream builder root ROOT builder compound builder k compound builder stream setup topology with intermediate user topic root ROOT topology compound topology setup case topic with amod topic intermediate compound topic user nmod with topology topic final string output topic root ROOT topic compound topic output
private final map NN string NN list NN partition NN info NN available JJ partitions NNS by IN topic NN private final map string list partition info root ROOT info compound info partition available partitions by topic root ROOT partitions amod partitions available case topic by nmod by partitions topic
private final map NN string NN list NN partition NN info NN partitions NNS by IN topic NN private final map string list partition info root ROOT info compound info partition partitions by topic root ROOT partitions case topic by nmod by partitions topic
private final set NN string NN internal JJ topics NNS private final set string internal topics root ROOT topics amod topics internal
public static cluster NN empty JJ public static cluster empty
public cluster NN with IN partitions NNS map NN topic NN partition NN partition NN info NN partitions NNS public cluster with partitions root ROOT partitions case partitions with map topic partition root ROOT partition compound partition topic partition info root ROOT info compound info partition partitions
public list NN node NN nodes NNS public list node nodes
public set NN string NN internal JJ topics NNS public set string internal topics root ROOT topics amod topics internal
public node NN controller NN public node controller
protected void update VB sample NN sample NN metric JJ config NN config NN double value NN long now RB protected void update sample sample metric config root ROOT config amod config metric config double value long now
public double combine VB list NN sample NN samples NNS metric JJ config NN config NN long now RB public double combine list sample samples metric config root ROOT config amod config metric config long now
public count NN public count
public record NN metadata NN topic NN partition NN topic NN partition NN long base NN offset VBD long relative JJ offset VBN long timestamp NN Long checksum NN int serialized VBN key JJ size NN int serialized VBN value NN size NN public record metadata root ROOT metadata compound metadata record topic partition root ROOT partition compound partition topic topic partition root ROOT partition compound partition topic long base offset root ROOT offset nsubj offset base long relative offset root ROOT relative dep relative offset long timestamp Long checksum int serialized key size root ROOT serialized amod size key dobj serialized size int serialized value size root ROOT size amod size serialized compound size value
public int partition NN public int partition
private final int serialized VBN key JJ size NN private final int serialized key size root ROOT serialized amod size key dobj serialized size
public object NN get VB negotiated VBN property NN string NN prop VB name NN public object get negotiated property root ROOT get amod property negotiated dobj get property string prop name root ROOT prop dobj prop name
public boolean is VBZ complete JJ public boolean is complete root ROOT complete cop complete is
private static final string NN jaas NN user NN prefix NN user NN private static final string jaas user prefix root ROOT prefix compound prefix jaas compound prefix user user
override NN public string NN get VB mechanism NN name NN override public string get mechanism name root ROOT get compound name mechanism dobj get name
visits this node then the test expression the true expression and the false expression override NN public void visit NN node NN visitor NN v LS visits this node then the test expression the true expression root ROOT visits det node this dobj visits node advmod expression then det expression the compound expression test nmod node expression det expression the amod expression true dep expression expression and the false expression root ROOT expression cc expression and det expression the amod expression false override public void visit node visitor root ROOT visitor compound visitor node v true false ANTONYM ANTONYM false void SYNONYM SYNONYM
override NN public boolean has VBZ side JJ effects NNS override public boolean has side effects root ROOT has amod effects side dobj has effects
public void set VBN colon NN position NN int colon NN position NN public void set colon position root ROOT set compound position colon dobj set position int colon position root ROOT position compound position colon
public int get VB colon NN position NN public int get colon position root ROOT get compound position colon dobj get position
public conditional JJ expression NN int pos NNS public conditional expression root ROOT expression amod expression conditional int pos
private ast IN node NN false JJ expression NN private ast node root ROOT node case node ast false expression root ROOT expression amod expression false
public live JJ connect VB drv NN string NN args NNS public live connect drv root ROOT live dep live connect dobj connect drv string args
public static void main JJ string NN args NNS public static void main string args
read the contents of a file into a string public static string NN read VB file NN string NN file NN path NN read the contents of a file into a string root ROOT read det contents the dobj read contents case file of det file a nmod of contents file case string into det string a nmod into read string public static string read file root ROOT read dobj read file string file path root ROOT path compound path file read file ANTONYM ANTONYM
from IN the DT current JJ date NN return a DT string NN in IN the DT format NN dd NN mm NN yy NN where WRB is VBZ specified VBN by IN the DT separator NN argument NN public static string NN get VB current JJ date NN string NN separator NN from the current date return a string in the format dd mm yy root ROOT yy compound yy dd compound yy mm where is specified by the separator argument public static string get current date root ROOT get amod date current dobj get date string separator
public boolean sleep NN int ms NNS public boolean sleep int ms
file NN test NN directory NN file test directory root ROOT directory compound directory test
generates code to wrap java arguments into object non primitive java types are left as is pending conversion in the helper method leaves the array object on the top of the stack in the helper method leaves the array object on the top of the stack static void generate VB push NN wrapped VBN args NNS class NN file NN writer NN cfw NN Class arg NN types NNS int array NN length NN generates code to wrap java arguments into object root ROOT generates dobj generates code mark wrap to advcl to generates wrap compound arguments java dobj wrap arguments case object into nmod into wrap object non primitive java types are left as is pending conversion root ROOT left amod types non amod types primitive compound types java nsubjpass left types auxpass left are advmod conversion as cop conversion is amod conversion pending ccomp left conversion in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack static void generate push wrapped args root ROOT generate compound args push amod args wrapped dobj generate args class file writer root ROOT writer compound writer class compound writer file cfw Class arg types root ROOT types compound types arg int array length root ROOT length compound length array generates leaves ANTONYM ANTONYM generates left ANTONYM ANTONYM leaves top ANTONYM ANTONYM left top ANTONYM ANTONYM
private static final int id NN java NN adapter NN private static final int id java adapter root ROOT adapter compound adapter id compound adapter java
Class interfaces NNS Class interfaces
java NN adapter NN signature NN Class super JJ class NN Class interfaces NNS obj NN to TO int VB map NN names NNS java adapter signature root ROOT signature compound signature java compound signature adapter Class super class root ROOT class amod class super Class interfaces obj to int map root ROOT obj mark int to acl to obj int dobj int map names
override NN public int hash VB code NN override public int hash code root ROOT hash dobj hash code
change the value of the internal flag that determines whether all storage is handed by a dense backing array rather than an associative store param dense only new value for dense only flag throws illegal argument exception if an attempt is made to enable dense only after it was disabled native array code is not written to handle switching back to a dense representation void set VBN dense JJ only RB boolean dense JJ only RB change the value of the internal flag that determines whether all root ROOT change det value the dobj change value case flag of det flag the amod flag internal nmod of value flag nsubj determines flag ref flag that acl relcl flag determines dobj determines whether det whether all storage is handed by a dense backing array rather than an associative root ROOT handed nsubjpass handed storage auxpass handed is case array by det array a amod array dense compound array backing nmod agent handed array cc array rather mwe rather than det associative an nmod agent handed associative conj negcc array associative store param dense only new value for dense only flag root ROOT value compound value param amod value dense advmod value only amod value new case flag for amod flag dense amod flag only nmod for value flag throws illegal argument exception if an attempt is made to enable root ROOT throws amod exception illegal compound exception argument dobj throws exception mark made if det attempt an nsubjpass made attempt nsubj xsubj enable attempt auxpass made is advcl if throws made mark enable to xcomp made enable dense only after it was disabled native array code is not written root ROOT written advmod written dense advmod code only mark code after nsubj code it cop code was amod code disabled amod code native compound code array nsubjpass written code auxpass written is neg written not to handle switching back to a dense representation root ROOT handle mark handle to dobj handle switching advmod handle back case representation to det representation a amod representation dense nmod to back representation void set dense only root ROOT set xcomp set dense advmod set only boolean dense only root ROOT dense advmod dense only change throws ANTONYM ANTONYM determines made ANTONYM ANTONYM enable disabled ANTONYM ANTONYM handed made ANTONYM ANTONYM handed throws ANTONYM ANTONYM is made ANTONYM ANTONYM made switching ANTONYM ANTONYM made was ANTONYM ANTONYM
private static void define VB elem NN context NN cx NN scriptable JJ target NN long index NN object NN value NN private static void define elem root ROOT define dobj define elem context cx scriptable target long index object value
private static void set VBN elem NNS context NN cx NN scriptable JJ target NN long index NN object NN value NN private static void set elem root ROOT set dobj set elem context cx scriptable target long index object value
public object NN remove VB int index NN public object remove int index
internal representation of the java script array s length property private long length NN internal representation of the java script array s length property root ROOT s amod representation internal nsubj s representation case array of det array the compound array java compound array script nmod of representation array compound property length dobj s property private long length internal private SYNONYM SYNONYM
the default capacity for code dense code private static final int default NN initial JJ capacity NN the default capacity for code dense code root ROOT capacity det capacity the compound capacity default case code for compound code code amod code dense nmod for capacity code private static final int default initial capacity root ROOT capacity compound capacity default amod capacity initial initial final ANTONYM ANTONYM
private static final int max NN pre JJ grow VB size NN int integer NN max NN value NN grow VB factor NN private static final int max pre grow size root ROOT max amod max pre dep pre grow dobj grow size int integer max root ROOT max compound max integer value grow factor root ROOT grow dobj grow factor
public int index NN of IN object NN o NN public int index of root ROOT index acl index of object o
public void set VBN flags NNS string NN flags NNS public void set flags root ROOT set dobj set flags string flags
override NN public string NN to TO source NN int depth NN override public string to source root ROOT source case source to int depth
private string NN js NNS to TO source NN private string js to source root ROOT js case source to nmod to js source
private namespace NN construct NN namespace NN private namespace construct namespace root ROOT namespace compound namespace construct
namespace NN cast VBN to TO namespace VB object NN namespace NN obj NN namespace cast to namespace root ROOT cast mark namespace to xcomp cast namespace object namespace obj root ROOT obj compound obj namespace
override NN public string NN get VB class NN name NN override public string get class name root ROOT get compound name class dobj get name
public string NN to TO locale NN string NN public string to locale string root ROOT string case string to compound string locale
private cache NN cache NN parent NN private cache cache parent
private simple JJ date NN format NN formatter NN private simple date format root ROOT format amod format simple compound format date formatter
first RB second JJ contained VBN in IN cache NN private long first RB Long MIN value NN first second contained in cache private long first Long MIN value second min ANTONYM ANTONYM
last JJ second JJ contained VBN in IN cache NN private long last JJ Long MIN value NN last second contained in cache private long last Long MIN value last second ANTONYM ANTONYM second min ANTONYM ANTONYM
index NN of IN first RB in IN the DT cyclic JJ cache NN private int offset VBN index of first in the cyclic cache private int offset
helper NN object NN to TO be VB able JJ to TO call NN simple JJ date NN format NN format NN private final date NN current JJ date NN new date NN helper object to be able to call simple date format format root ROOT format amod format simple compound format date compound format format private final date current date root ROOT date amod date current new date
binds a new name to the object bound to an old name and unbinds the old name param old name the name of the existing binding may not be empty param new name the name of the new binding may not be empty exception name already bound exception if new name is already bound exception naming exception if a naming exception is encountered override NN public void rename VB string NN old JJ name NN string NN new JJ name NN throws naming VBG exception NN binds a new name to the object bound to an old name and unbinds the root ROOT bound csubj bound binds csubj unbinds binds det name a amod name new dobj binds name case object to det object the nmod to binds object case name to det name an amod name old nmod to bound name cc bound and conj and bound unbinds dobj unbinds the old name root ROOT name amod name old param old name the name of the existing binding may not be empty root ROOT empty compound name param amod name old dobj empty name det name the nsubj empty name case binding of det binding the amod binding existing nmod of name binding aux empty may neg empty not cop empty be param new name the name of the new binding may not be empty root ROOT param amod name new dobj param name det name the nsubj empty name case binding of det binding the amod binding new nmod of name binding aux empty may neg empty not cop empty be acl relcl name empty exception name already bound exception if new name is already bound root ROOT bound compound name exception nsubj bound name advmod bound already dobj bound exception mark bound if amod name new nsubjpass bound name auxpass bound is advmod bound already advcl if bound bound exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public void rename string old name root ROOT name amod name old string new name root ROOT name amod name new throws naming exception root ROOT naming dobj naming exception be naming ANTONYM ANTONYM binding throws ANTONYM ANTONYM binds throws ANTONYM ANTONYM binds unbinds ANTONYM ANTONYM is naming ANTONYM ANTONYM name be ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM new old ANTONYM ANTONYM unbinds binding ANTONYM ANTONYM
enumerates the names bound in the named context along with the class names of objects bound to them param name the name of the context to list return an enumeration of the names and class names of the bindings in this context each element of the enumeration is of type name class pair this context each element of the enumeration is of type name class pair exception naming exception if a naming exception is encountered override NN public naming VBG enumeration NN name NN class NN pair NN list NN string NN name NN throws naming VBG exception NN enumerates the names bound in the named context along with the class root ROOT enumerates det names the dobj enumerates names acl names bound case context in det context the amod context named nmod in bound context case class along mwe along with det class the nmod along with names class names of objects bound to them root ROOT names case objects of nmod of names objects acl objects bound case them to nmod to bound them param name the name of the context to list root ROOT name compound name param det name the dep name name case context of det context the nmod of name context case list to nmod to name list return an enumeration of the names and class names of the bindings in root ROOT return det enumeration an dobj return enumeration case names of det names the nmod of enumeration names cc names and compound names class nmod of enumeration names conj and names names case bindings of det bindings the nmod of names bindings dep return in this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public naming enumeration root ROOT naming dobj naming enumeration name class pair root ROOT pair compound pair name compound pair class list string name throws naming exception root ROOT naming dobj naming exception enumerates list ANTONYM ANTONYM is naming ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM names is ANTONYM ANTONYM names throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM return throws ANTONYM ANTONYM
retrieves the named object following links except for the terminal atomic component of the name if the object bound to name is not a atomic component of the name if the object bound to name is not a link returns the object itself param name the name of the object to look up return the object bound to name not following the terminal link if any exception naming exception if a naming exception is encountered override NN public object NN lookup NN link NN name NN name NN throws naming VBG exception NN retrieves the named object following links except for the terminal root ROOT retrieves det object the amod object named dobj retrieves object case links following nmod following retrieves links case terminal except mwe except for det terminal the nmod except for links terminal atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not link returns the object itself root ROOT returns nsubj returns link det object the dobj returns object nmod npmod returns itself param name the name of the object to look up root ROOT name compound name param det name the dep name name case object of det object the nmod of name object mark look to acl to name look compound prt look up return the object bound to name not following the terminal link root ROOT return det object the nsubj bound object nsubj xsubj name object ccomp return bound mark name to xcomp bound name neg following not xcomp name following det link the amod link terminal dobj following link if any root ROOT any mark any if exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public object lookup link root ROOT link compound link lookup name name throws naming exception root ROOT naming dobj naming exception is naming ANTONYM ANTONYM look encountered ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM retrieves encountered ANTONYM ANTONYM retrieves return ANTONYM ANTONYM retrieves returns ANTONYM ANTONYM return throws ANTONYM ANTONYM returns throws ANTONYM ANTONYM
protected boolean is VBZ writable JJ protected boolean is writable root ROOT writable cop writable is
release the lock for the given mutex param mutex the mutex from which to release the lock return the operation status public static native int unlock NN long mutex NN release the lock for the given mutex root ROOT release det lock the dobj release lock case mutex for det mutex the amod mutex given nmod for release mutex param mutex the mutex from which to release the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod from release mutex case which from ref mutex which mark release to acl relcl mutex release det lock the dobj release lock return the operation status root ROOT return det status the compound status operation dobj return status public static native int unlock long mutex lock unlock ANTONYM ANTONYM release given ANTONYM ANTONYM
destroy the mutex and free the memory associated with the lock param mutex the mutex to destroy return the operation status public static native int destroy VB long mutex NN destroy the mutex and free the memory associated with the lock root ROOT destroy det mutex the dobj destroy mutex cc mutex and amod memory free det memory the dobj destroy memory conj and mutex memory acl mutex associated case lock with det lock the nmod with associated lock param mutex the mutex to destroy root ROOT mutex compound mutex param det mutex the dep mutex mutex mark destroy to acl to mutex destroy return the operation status root ROOT return det status the compound status operation dobj return status public static native int destroy long mutex lock free ANTONYM ANTONYM
public static native string NN defname NN public static native string defname
public static final int apr NN lock NN flock NN flock NN public static final int apr lock flock root ROOT flock compound flock apr compound flock lock flock
public static final int apr NN lock NN default NN use NN the DT default process NN lock NN public static final int apr lock default root ROOT default compound default apr compound default lock use the default process lock
acquire the lock for the given mutex if the mutex is already locked acquire the lock for the given mutex if the mutex is already locked the current thread will be put to sleep until the lock becomes available param mutex the mutex on which to acquire the lock return the operation status public static native int lock NN long mutex NN acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked the current thread will be put to sleep until the lock becomes available root ROOT put det thread the amod thread current nsubjpass put thread nsubj xsubj sleep thread aux put will auxpass put be mark sleep to xcomp put sleep mark becomes until det lock the nsubj becomes lock advcl until sleep becomes xcomp becomes available param mutex the mutex on which to acquire the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod on acquire mutex case which on ref mutex which mark acquire to acl relcl mutex acquire det lock the dobj acquire lock return the operation status root ROOT return det status the compound status operation dobj return status public static native int lock long mutex acquire becomes ANTONYM ANTONYM given acquire ANTONYM ANTONYM given put ANTONYM ANTONYM given will ANTONYM ANTONYM
determine if pool a is an ancestor of pool b param a the pool to search param b the pool to search for return true if a is an ancestor of b null is considered an ancestor of all pools public static native boolean is VBZ ancestor NN long a DT long b NN determine if pool a is an ancestor of pool b root ROOT determine mark ancestor if compound a pool nsubj ancestor a cop ancestor is det ancestor an advcl if determine ancestor case b of compound b pool nmod of ancestor b param a the pool to search root ROOT param det pool a det pool the dobj param pool mark search to acl to pool search param b the pool to search for root ROOT b compound b param det pool the dep b pool mark search to acl to pool search nmod search for return true if a is an ancestor of b null is considered an ancestor root ROOT considered nsubjpass considered return amod return true mark ancestor if nsubj ancestor a cop ancestor is det ancestor an advcl if true ancestor case null of compound null b nmod of ancestor null auxpass considered is det ancestor an xcomp considered ancestor of all pools root ROOT pools case pools of det pools all public static native boolean is ancestor root ROOT ancestor cop ancestor is long a long b determine considered ANTONYM ANTONYM
clear all memory in the pool and run all the cleanups this also destroys all clear all memory in the pool and run all the cleanups this also destroys all subpools param pool the pool to clear this does not actually free the memory it just allows the pool to re use this memory for the next allocation public static native void clear JJ long pool NN clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all subpools param pool the pool to clear root ROOT pool compound pool param det pool the dep pool pool case clear to nmod to pool clear this does not actually free the memory it just allows the pool root ROOT free nsubj free this aux free does neg free not advmod free actually det memory the dobj free memory nsubj allows it advmod allows just acl relcl memory allows det pool the dobj allows pool to re use this memory for the next allocation root ROOT re mark re to dobj re use det memory this dobj use memory case allocation for det allocation the amod allocation next nmod for use allocation public static native void clear long pool clear does ANTONYM ANTONYM clear free ANTONYM ANTONYM clear just ANTONYM ANTONYM clear run ANTONYM ANTONYM does use ANTONYM ANTONYM free allows ANTONYM ANTONYM free use ANTONYM ANTONYM public clear ANTONYM ANTONYM run does ANTONYM ANTONYM clear native SYNONYM SYNONYM in next SYNONYM SYNONYM
create a new pool param parent the parent pool if this is the new pool is a root param parent the parent pool if this is the new pool is a root pool if it is non zero the new pool will inherit all pool if it is non zero the new pool will inherit all of its parent pool s attributes except the apr pool t will be a sub pool return the pool we have just created public static native long create VB long parent NN create a new pool root ROOT create det pool a amod pool new dobj create pool param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all of its parent pool s attributes except the apr pool t will root ROOT s case s of nmod poss s its compound s parent compound s pool acl s attributes case t except det t the compound t apr compound t pool nmod except attributes t dep s will be a sub pool root ROOT pool cop pool be det pool a compound pool sub return the pool we have just created root ROOT created dep created return det pool the dobj return pool nsubj created we aux created have advmod created just public static native long create long parent create have ANTONYM ANTONYM have created ANTONYM ANTONYM just new ANTONYM ANTONYM return have ANTONYM ANTONYM zero all ANTONYM ANTONYM
public void set VBN adapter NN adapter NN adapter NN public void set adapter root ROOT set dobj set adapter adapter adapter
protected void set VBN error NN state NN error NN state NN error NN state NN throwable JJ t NN protected void set error state root ROOT set compound state error dobj set state error state root ROOT state compound state error error state root ROOT state compound state error throwable t
public abstract JJ processor NN abstract JJ endpoint NN endpoint NN public abstract processor root ROOT processor amod processor abstract abstract endpoint root ROOT endpoint amod endpoint abstract endpoint
private error NN state NN error NN state NN error NN state NN none NN private error state root ROOT state compound state error error state root ROOT state compound state error error state none root ROOT none compound none error compound none state
override NN public boolean is VBZ async NN override public boolean is async root ROOT async cop async is
protected executor NN get VB executor NN protected executor get executor root ROOT get dobj get executor
private abstract JJ processor NN abstract JJ endpoint NN endpoint NN request NN coyote NN request NN response NN coyote NN response NN private abstract processor root ROOT processor amod processor abstract abstract endpoint root ROOT endpoint amod endpoint abstract endpoint request coyote request root ROOT request compound request coyote response coyote response root ROOT response compound response coyote
public void action NN action NN code NN action NN code NN object NN param NN public void action action code root ROOT code compound code action action code root ROOT code compound code action object param
public response NN get VB response NN public response get response root ROOT get dobj get response
public message NN bytes NNS content JJ type NN public message bytes root ROOT bytes compound bytes message content type root ROOT type amod type content
public message NN bytes NNS remote JJ addr NN public message bytes root ROOT bytes compound bytes message remote addr root ROOT addr amod addr remote
public void set VBN read NN listener NN read VB listener NN listener NN public void set read listener root ROOT set compound listener read dobj set listener read listener root ROOT read dobj read listener listener
private boolean expectation NN false JJ private boolean expectation false
private long content JJ length NN private long content length root ROOT length amod length content
private final u NN decoder NN url NN decoder NN new u NN decoder NN private final u decoder root ROOT decoder compound decoder u url decoder root ROOT decoder compound decoder url new u decoder root ROOT decoder compound decoder u
private final map NN string NN string NN path NN parameters NNS new hash VB map NN  private final map string string path parameters root ROOT parameters compound parameters path new hash map root ROOT hash dobj hash map
