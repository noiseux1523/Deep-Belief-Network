LAPD;Problematic
free this sorter s data pages return the number of bytes freed private long free JJ memory NN free this sorter s data pages root ROOT pages amod pages free det sorter this compound pages sorter compound pages s compound pages data return the number of bytes freed root ROOT return det number the dobj return number case bytes of nmod of number bytes acl number freed private long free memory root ROOT memory amod memory free return number ANTONYM ANTONYM;0
public int get VB num NN records NNS public int get num records root ROOT get compound records num dobj get records;0
public boolean has VBZ next JJ public boolean has next root ROOT has advmod has next;0
public int get VB record NN length NN public int get record length root ROOT get compound length record dobj get length;0
private final prefix NN comparator NN prefix NN comparator NN private final prefix comparator root ROOT comparator compound comparator prefix prefix comparator root ROOT comparator compound comparator prefix;0
marks the current page as no more space available and as a result either allocate a new page or spill when we see the next record visible JJ for IN testing NN public void close RB current JJ page NN marks the current page as no more space available and as a result either allocate a root ROOT marks det page the amod page current dobj marks page case space as neg space no amod space more nmod as marks space amod space available cc marks and case result as det result a conj and marks result cc preconj allocate either acl result allocate dobj allocate a new page or spill when we see the next record root ROOT page amod page new cc page or conj or page spill advmod see when nsubj see we acl relcl page see det record the amod record next dobj see record visible for testing root ROOT visible case testing for nmod for visible testing public void close current page root ROOT page amod page close amod page current marks record ANTONYM ANTONYM marks see ANTONYM ANTONYM;0
private void update VB peak NN memory NN used VBN private void update peak memory used root ROOT update compound memory peak dobj update memory acl memory used;0
private static void sort NN key JJ prefix NN array NN at IN byte NN long RB array NN array NN long num NN records NNS long counts NNS int byte NN idx NN long in IN index NN long out IN index NN boolean desc NN boolean signed VBN private static void sort key prefix array at byte root ROOT array compound array sort amod array key compound array prefix case byte at nmod at array byte long array root ROOT array advmod array long array long num records root ROOT records compound records num long counts int byte idx root ROOT idx compound idx byte long in index root ROOT index case index in long out index root ROOT index case index out boolean desc boolean signed;0
public void write VB byte b NN int off IN int len NN throws io NN exception NN public void write byte b int off int len throws io exception root ROOT exception compound exception io;0
private string NN filename NN private string filename;0
private print NN stream NN output NN stream NN private print stream root ROOT stream compound stream print output stream root ROOT stream compound stream output;0
public file NN stream NN sink NN task NN print NN stream NN output NN stream NN public file stream sink task root ROOT task compound task file compound task stream compound task sink print stream root ROOT stream compound stream print output stream root ROOT stream compound stream output;0
public void start NN map NN string NN string NN props NNS public void start map string string props;0
private void set VBN timeout NN private void set timeout root ROOT set dobj set timeout;0
public void stop VB public void stop;0
public static final long default NN failure NN delay NN ms NNS public static final long default failure delay ms root ROOT ms compound ms default compound ms failure compound ms delay;0
private static final logger NN log NN logger NN factory NN get VB logger NN MockConnector class private static final logger log logger factory get logger root ROOT get compound factory logger nsubj get factory dobj get logger MockConnector class;0
final string NN transformation NN name NN final string transformation name root ROOT name compound name transformation;0
private doc NN info NN string NN transformation NN name NN string NN overview NN config NN def NN config NN def NN private doc info root ROOT info compound info doc string transformation name root ROOT name compound name transformation string overview config def root ROOT def compound def config config def root ROOT def compound def config;0
private static void print NN transformation NN html NN print NN stream NN out IN doc NN info NN doc NN info NN private static void print transformation html root ROOT html compound html print compound html transformation print stream root ROOT stream compound stream print out doc info root ROOT info compound info doc doc info root ROOT info compound info doc;0
private static void print NN html NN print NN stream NN out IN throws no DT such JJ field NN exception NN illegal JJ access NN exception NN instantiation NN exception NN private static void print html root ROOT html compound html print print stream root ROOT stream compound stream print out throws no such field exception root ROOT field neg field no amod field such dep field exception illegal access exception root ROOT exception amod exception illegal compound exception access instantiation exception root ROOT exception compound exception instantiation;0
public static void main JJ string NN args NNS throws exception NN public static void main string args throws exception;0
public config NN def NN config NN public config def root ROOT def compound def config config;0
public offset VBN storage NN reader NN offset VBN storage NN reader NN public offset storage reader root ROOT reader amod reader offset compound reader storage offset storage reader root ROOT reader amod reader offset compound reader storage;0
private final offset VBN storage NN reader NN reader NN private final offset storage reader root ROOT reader amod reader offset compound reader storage reader;0
protected final class NN loader NN loader NN protected final class loader root ROOT loader compound loader class loader;0
protected final connector NN task NN id NN id NN protected final connector task id root ROOT id compound id connector compound id task id;0
private volatile target NN state NN target NN state NN private volatile target state root ROOT state compound state target target state root ROOT state compound state target;0
cancel this task this won t actually stop it but it will prevent the state from being cancel this task this won t actually stop it but it will prevent the state from being updated when it eventually does shutdown public void cancel VB cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being cancel this task this won t actually stop it but it will prevent the state from being root ROOT cancel det task this dobj cancel task nsubj won this dep cancel won dobj won t advmod stop actually dep won stop dobj stop it cc stop but nsubj prevent it aux prevent will dep won prevent conj but stop prevent det state the dobj prevent state mark being from advcl from prevent being updated when it eventually does shutdown root ROOT updated advmod does when nsubj does it advmod does eventually advcl updated does dobj does shutdown public void cancel cancel void ANTONYM ANTONYM stop shutdown ANTONYM ANTONYM;0
public pane NN info NN tracker NN timer NN internals NNS timer NN internals NNS public pane info tracker root ROOT tracker compound tracker pane compound tracker info timer internals root ROOT internals compound internals timer timer internals root ROOT internals compound internals timer;0
public boolean is VBZ empty JJ public boolean is empty root ROOT empty cop empty is;0
private set NN p NN collection NN view NN views NNS private set p collection view root ROOT view compound view p compound view collection views;0
public void delete VB timer NN instant NN timestamp NN time NN domain NN time NN domain NN public void delete timer root ROOT delete dobj delete timer instant timestamp time domain root ROOT domain compound domain time time domain root ROOT domain compound domain time;0
public void set VBN timer NN instant NN timestamp NN time NN domain NN time NN domain NN public void set timer root ROOT set dobj set timer instant timestamp time domain root ROOT domain compound domain time time domain root ROOT domain compound domain time;0
protected final active JJ window NN set NN w NN active JJ windows NNS protected final active window set root ROOT set amod set active compound set window w active windows root ROOT windows amod windows active;0
protected final state NN context NN w NN context NN protected final state context root ROOT context compound context state w context;0
protected final state NN internals NNS state NN internals NNS protected final state internals root ROOT internals compound internals state state internals root ROOT internals compound internals state;0
public k NN key NN public k key k key ANTONYM ANTONYM;0
add an end of window hold or if too late for that a garbage collection hold if required return the link instant at which hold was added or literal null if no hold was added nullable JJ private instant NN add VB end NN of IN window NN or CC garbage NN collection NN holds VBZ reduce VB fn NN w NN context NN context NN boolean pane NN is VBZ empty JJ add an end of window hold or if too late for that a garbage collection hold if required root ROOT add det end an dobj add end case hold of compound hold window nmod of end hold cc add or case late if advmod late too conj or add late mark hold for mark hold that det collection a compound collection garbage nsubj hold collection dep late hold mark required if advcl if hold required return the link instant at which hold was added or literal null if no hold was added root ROOT return det instant the compound instant link dobj return instant nmod at added instant case which at ref instant which aux added hold auxpass added was acl relcl instant added cc added or amod null literal acl relcl instant null conj or added null mark added if neg hold no nsubjpass added hold auxpass added was dep added added nullable private instant add end of window or garbage collection holds root ROOT holds csubj holds add dobj add end case window of nmod of end window cc window or compound collection garbage nmod of end collection conj or window collection reduce fn root ROOT reduce dobj reduce fn w context context boolean pane is empty root ROOT empty nsubj empty pane cop empty is hold required ANTONYM ANTONYM hold return ANTONYM ANTONYM;0
public void prefetch NN on IN merge VBP merging VBG state NN accessor NN w NN state NN public void prefetch on merge root ROOT merge nsubj merge prefetch acl prefetch on merging state accessor root ROOT merging compound accessor state dobj merging accessor w state;0
public string NN string NN key NN public string string key root ROOT key compound key string;0
public boolean equals VBZ object NN obj NN public boolean equals object obj;0
public int hash VB code NN public int hash code root ROOT hash dobj hash code;0
public string NN to TO string VB public string to string root ROOT string mark string to;0
private static final string NN window NN format NN s NNS private static final string window format root ROOT format compound format window s;0
public w NN get VB window NN public w get window root ROOT get dobj get window;0
private final duration NN allowed VBN lateness NN private final duration allowed lateness root ROOT allowed dobj allowed lateness;0
private final boolean observes VBZ window NN private final boolean observes window root ROOT observes dobj observes window;0
private final side NN input NN reader NN side NN input NN reader NN private final side input reader root ROOT reader compound reader side compound reader input side input reader root ROOT reader compound reader side compound reader input;0
the DT set NN of IN known VBN output NN tags NNS private final set NN tuple NN tag NN output NN tags NNS the set of known output tags private final set tuple tag root ROOT tag compound tag tuple output tags root ROOT tags compound tags output set tags ANTONYM ANTONYM;0
public void start VB bundle NN public void start bundle root ROOT start dobj start bundle;0
public void process NN element NN windowed JJ value NN input NN t NN compressed VBN elem NN public void process element root ROOT element compound element process windowed value root ROOT value amod value windowed input t root ROOT t compound t input compressed elem root ROOT elem amod elem compressed;0
public pipeline NN options NNS get VB pipeline NN options NNS public pipeline options root ROOT options compound options pipeline get pipeline options root ROOT get compound options pipeline dobj get options;0
public bounded VBN window NN window NN public bounded window root ROOT window amod window bounded window;0
public void output NN output NN t NN output NN public void output output t root ROOT t compound t output output;0
public state NN state NN string NN state NN id NN public state state string state id root ROOT id compound id state;0
the state namespace for this context p any call to this method when more than one window is present will crash this represents a bug in the runner or the link do fn signature since values must be in exactly one window when state or timers are relevant private state NN namespace NN get VB namespace NN the state namespace for this context root ROOT namespace det namespace the compound namespace state case context for det context this nmod for namespace context p any call to this method when more than one window is present will crash this root ROOT crash dep crash p det call any nsubj crash call case method to det method this nmod to call method advmod present when advmod one more mwe more than nummod window one nsubj present window cop present is acl relcl call present aux crash will dobj crash this represents a bug in the runner or the link do fn signature since values must be in exactly root ROOT represents det bug a dobj represents bug case runner in det runner the nmod in bug runner cc runner or det link the nmod in bug link conj or runner link dep represents do compound signature fn dobj do signature mark exactly since nsubj exactly values aux exactly must cop exactly be case exactly in advcl since do exactly one window when state or timers are relevant root ROOT window nummod window one advmod relevant when nsubj relevant state cc state or conj or state timers nsubj relevant timers cop relevant are acl relcl window relevant private state namespace root ROOT namespace compound namespace state get namespace root ROOT get dobj get namespace is present ANTONYM ANTONYM state present ANTONYM ANTONYM;0
private duration NN period NN duration NN zero CD private duration period duration zero root ROOT duration nummod duration zero;0
private duration NN offset VBN duration NN zero CD private duration offset duration zero root ROOT duration nummod duration zero;0
override NN public void set NN relative JJ override public void set relative root ROOT set dep set relative;0
sets the timer for the target time without checking anything about whether it is a reasonable thing to do for example absolute processing time timers are not a reasonable thing to do for example absolute processing time timers are not really sensible since the user has no way to compute a good choice of time private void set VBN underlying VBG timer NN instant NN target NN sets the timer for the target time without checking anything about whether it is root ROOT sets det timer the dobj sets timer case time for det time the compound time target nmod for timer time mark checking without advcl without sets checking dobj checking anything mark is about mark is whether nsubj is it acl whether anything is a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not a reasonable thing to do for example absolute processing time timers are not root ROOT thing det thing a amod thing reasonable mark do to acl to thing do case timers for compound timers example amod timers absolute compound timers processing compound timers time nmod for do timers dep thing are neg are not really sensible since the user has no way to compute a good choice of time root ROOT sensible advmod sensible really mark has since det user the nsubj has user advcl since sensible has neg way no dobj has way mark compute to acl to way compute det choice a amod choice good dobj compute choice case time of nmod of choice time private void set underlying timer root ROOT set xcomp set underlying dobj underlying timer instant target checking has ANTONYM ANTONYM do has ANTONYM ANTONYM do processing ANTONYM ANTONYM reasonable good ANTONYM ANTONYM sensible good ANTONYM ANTONYM sets checking ANTONYM ANTONYM sets target ANTONYM ANTONYM void good ANTONYM ANTONYM absolute good SYNONYM SYNONYM;0
public peeking VBG reiterator NN reiterator NN t NN iterator NN public peeking reiterator root ROOT peeking dobj peeking reiterator reiterator t iterator;0
public t NN next IN public t next;0
private void compute VB next IN private void compute next root ROOT compute advmod compute next;0
private final metric JJ name NN name NN private final metric name root ROOT name amod name metric name;0
public metric JJ name NN get VB name NN public metric name root ROOT name amod name metric get name root ROOT get dobj get name;0
public dirty JJ state NN get VB dirty JJ public dirty state root ROOT state amod state dirty get dirty root ROOT get xcomp get dirty;0
internal JJ public distribution NN cell NN metric JJ name NN name NN internal public distribution cell root ROOT cell compound cell distribution metric name root ROOT name amod name metric name;0
public iterable JJ t NN values NNS public iterable t values;0
abstract read VB k NN v LS build VB abstract read k v build k v SYNONYM SYNONYM;0
public configuration NN get VB public configuration get;0
public serializable JJ configuration NN configuration NN conf NN public serializable configuration root ROOT configuration amod configuration serializable configuration conf;0
private transient configuration NN conf NN private transient configuration conf;0
private static final long serial JJ version NN uid NN l NN private static final long serial version uid root ROOT uid amod uid serial compound uid version l;0
private static final string NN default NN appname NN beam NN gearpump NN app NN private static final string default appname root ROOT appname compound appname default beam gearpump app root ROOT app compound app beam compound app gearpump;0
protected string NN result NN path NN protected string result path root ROOT path compound path result;0
private final instant NN offset VBN private final instant offset;0
public string NN to TO string VB public string to string root ROOT string mark string to;0
public delay NN fn NN duration NN delay NN public delay fn root ROOT fn compound fn delay duration delay;0
public void clear JJ trigger NN context NN c NN throws exception NN public void clear trigger context root ROOT context compound context trigger c throws exception clear throws ANTONYM ANTONYM public clear ANTONYM ANTONYM;0
w NN write VB state NN address NN w NN window NN w write state address root ROOT write compound address state dobj write address w window;0
will children be started automatically when they are added protected boolean start VB children NNS true JJ will children be started automatically when they are added root ROOT started aux started will nsubjpass started children auxpass started be advmod started automatically advmod added when nsubjpass added they auxpass added are advcl started added protected boolean start children root ROOT start dobj start children true added started ANTONYM ANTONYM;0
private in IN memory NN timer NN internals NNS timer NN internals NNS private in memory timer internals root ROOT internals case internals in compound internals memory compound internals timer timer internals root ROOT internals compound internals timer;0
public void close RB throws exception NN public void close throws exception public close ANTONYM ANTONYM;0
private final metric JJ update VBP t NN committed VBN private final metric update root ROOT update nsubj update metric t committed;0
public string NN step NN public string step;0
private accumulated VBN metric JJ result NN metric JJ name NN name NN string NN step NN t NN attempted VBN t NN committed VBN boolean is VBZ committed VBN supported VBN private accumulated metric result root ROOT result amod result accumulated amod result metric metric name root ROOT name amod name metric name string step t attempted t committed boolean is committed supported root ROOT committed auxpass committed is dep committed supported;0
public iterable JJ map NN entry NN k NN t NN entries NNS public iterable map entry root ROOT entry compound entry map k t entries;0
public iterable JJ t NN values NNS public iterable t values;0
Transient fields NNS that IN are VBP lazy JJ initialized VBN and CC then RB memoized VBN private transient extension NN registry NN memoized JJ extension NN registry NN Transient fields that are lazy initialized and then memoized private transient extension registry root ROOT registry compound registry extension memoized extension registry root ROOT registry amod registry memoized compound registry extension;0
static final type NN descriptor NN message NN message NN type NN new type NN descriptor NN message NN static final type descriptor root ROOT descriptor compound descriptor type message message type root ROOT type compound type message new type descriptor root ROOT descriptor compound descriptor type message;0
sets function name and sets its parent to this node param name function name code null for anonymous functions public void set NN function NN name NN name NN name NN sets function name and sets its parent to this node root ROOT function nsubj function sets nsubj sets sets dobj function name cc function and conj and function sets nmod poss parent its dobj sets parent case node to det node this nmod to sets node param name function name code null for anonymous functions root ROOT null compound null param compound null name compound null function compound null name compound null code case functions for amod functions anonymous nmod for null functions public void set function name root ROOT name compound name set compound name function name name name parent ANTONYM ANTONYM;0
public set NN Class get VB extension NN hosts NNS public set Class get extension hosts root ROOT get compound hosts extension dobj get hosts;0
public object NN to TO object VB public object to object root ROOT object mark object to;0
public int value NN public int value;0
public final int doc NN id NN public final int doc id root ROOT id compound id doc;0
private final disjunction NN disi NN approximation NN approximation NN private final disjunction disi approximation root ROOT approximation compound approximation disjunction compound approximation disi approximation;0
escape NN character NN public static final char wildcard NN escape NN escape character public static final char wildcard escape root ROOT escape compound escape wildcard;0
starting VBG term NN ord NN for this frame NN used VBN to TO reset VB term NN ord NN in IN rewind NN long term NN ord NN orig NN starting term ord root ROOT ord compound ord term for this frame used to reset term ord root ROOT ord compound ord term in rewind long term ord orig root ROOT orig compound orig term compound orig ord;0
placeholder NN for missing VBG offset VBN that IN means NNS all DT values NNS are VBP missing VBG static final int all DT missing VBG placeholder for missing offset that means all values are missing static final int all missing root ROOT missing dep missing all;0
public name NN get VB function NN name NN public name get function name root ROOT get compound name function dobj get name;0
static final int sorted VBN single JJ valued VBN static final int sorted single valued root ROOT sorted xcomp sorted single dep single valued;0
build VB reverse NN index NN from IN every DT th DT term NN static final int reverse JJ interval NN shift NN build reverse index from every th term static final int reverse interval shift root ROOT shift amod shift reverse compound shift interval;0
final int stack VB final int stack;0
public terms NNS enum VBP with IN slice NN int index NN reader NN slice NN sub NN slice NN public terms enum with slice root ROOT enum nsubj enum terms case slice with nmod with enum slice int index reader slice root ROOT slice compound slice reader sub slice root ROOT slice compound slice sub;0
Default maximum NN number NN of IN point NN in IN each DT leaf NN block NN public static final int default NN max NN points NNS in IN leaf NN node NN Default maximum number of point in each leaf block public static final int default max points in leaf node root ROOT points compound points default compound points max case node in compound node leaf nmod in points node block points ANTONYM ANTONYM point block ANTONYM ANTONYM;0
private final int bytes NNS per IN doc NN private final int bytes per doc root ROOT bytes case doc per nmod per bytes doc;0
private list NN ast IN node NN params NNS private list ast node root ROOT node case node ast params;0
writes VBZ the DT bkd NN tree NN to TO the DT provided VBN writes the bkd tree to the provided;0
private term NN iterator NN iterator NN private term iterator root ROOT iterator compound iterator term iterator;0
public void visit NN int doc NN id NN public void visit int doc id root ROOT id compound id doc;0
Public final boolean equals VBZ object NN other JJ Public final boolean equals object other;0
byte point NN bytes NNS new byte bytes NNS per IN dim NN byte point bytes root ROOT bytes compound bytes point new byte bytes per dim root ROOT bytes case dim per nmod per bytes dim;0
private boolean is VBZ wildcard NN char NN sequence NN text NN private boolean is wildcard root ROOT wildcard cop wildcard is char sequence root ROOT sequence compound sequence char text;0
public double JJ metaphone NN filter NN create VB token JJ stream NN input NN public double metaphone filter root ROOT filter amod filter double compound filter metaphone create token stream root ROOT stream amod stream token input;0
creates VBZ a DT new double JJ metaphone NN filter NN factory NN public double JJ metaphone NN filter NN factory NN map NN string NN string NN args NNS creates a new double metaphone filter factory root ROOT factory amod factory double compound factory metaphone compound factory filter public double metaphone filter factory root ROOT factory amod factory double compound factory metaphone compound factory filter map string string args;0
private boolean is VBZ generator NN private boolean is generator root ROOT generator cop generator is;0
protected void initialize VB iterator NN throws io NN exception NN protected void initialize iterator root ROOT initialize dobj initialize iterator throws io exception root ROOT exception compound exception io;0
private int final JJ offset VBN private int final offset root ROOT offset advmod offset final;0
private final offset VBN attribute NN offset VBN attr NN private final offset attribute root ROOT attribute amod attribute offset offset attr root ROOT offset dobj offset attr;0
private final char NN term NN attribute NN term NN attr NN private final char term attribute root ROOT attribute compound attribute char compound attribute term term attr root ROOT attr compound attr term;0
the DT list NN of IN holes NNS If a DT point NN is VBZ in IN the DT hole NN it PRP is VBZ not RB in IN the DT polygon NN protected final list NN geo NN polygon NN holes NNS the list of holes If a point is in the hole it is not in the polygon protected final list geo polygon root ROOT polygon compound polygon geo holes;0
the DT list NN of IN polygon NN points NNS protected final list NN geo NN point NN points NNS the list of polygon points protected final list geo point root ROOT point compound point geo points;0
check NN if a DT point NN is VBZ within IN the DT provided VBN holes NNS param point point to check return true if the point is within any of the holes protected boolean is VBZ within IN holes NNS final geo NN point NN point NN check if a point is within the provided holes param point point to check root ROOT point compound point param compound point point mark check to acl to point check return true if the point is within any of the holes root ROOT return amod return true mark any if det point the nsubj any point cop any is case any within advcl within true any case holes of det holes the nmod of any holes protected boolean is within holes root ROOT holes cop holes is case holes within final geo point root ROOT point compound point geo point check point ANTONYM ANTONYM check return ANTONYM ANTONYM provided return ANTONYM ANTONYM;0
protected boolean local JJ is VBZ within IN final vector NN v LS protected boolean local is within root ROOT within nsubj within local cop within is final vector v;0
public geo NN point NN get VB edge NN points NNS public geo point root ROOT point compound point geo get edge points root ROOT get compound points edge dobj get points;0
public boolean is VBZ expression NN closure NN public boolean is expression closure root ROOT closure cop closure is compound closure expression;0
public string NN to TO string VB public string to string root ROOT string mark string to;0
private static final string NN brokers NNS key JJ name NN brokers NNS private static final string brokers key name root ROOT name compound name brokers amod name key brokers;0
public metadata NN response NN int throttle NN time NN ms NNS list NN node NN brokers NNS string NN cluster NN id NN int controller NN id NN list NN topic NN metadata NN topic NN metadata NN public metadata response root ROOT response compound response metadata int throttle time ms root ROOT ms compound ms throttle compound ms time list node brokers string cluster id root ROOT id compound id cluster int controller id root ROOT id compound id controller list topic metadata root ROOT metadata compound metadata topic topic metadata root ROOT metadata compound metadata topic;0
public list NN acl NN creation NN acl NN creations NNS public list acl creation root ROOT creation compound creation acl acl creations root ROOT creations compound creations acl;0
private static final long commit VB interval NN ms NNS l NN private static final long commit interval ms root ROOT commit compound ms interval dobj commit ms l;0
private int next JJ timeout NN ms NNS private int next timeout ms root ROOT ms amod ms next compound ms timeout;0
check for calls which have timed out timed out calls will be removed and failed the remaining milliseconds until the next timeout will be updated param calls the collection of calls return the number of calls which were timed out int handle VB timeouts NNS collection NN call NN calls NNS string NN msg NN check for calls which have timed out root ROOT check case calls for nmod for check calls nsubj timed calls ref calls which aux timed have acl relcl calls timed compound prt timed out timed out calls will be removed and failed root ROOT removed amod calls timed compound prt timed out nsubjpass removed calls nsubjpass failed calls aux removed will auxpass removed be cc removed and conj and removed failed the remaining milliseconds until the next timeout will be updated root ROOT milliseconds det milliseconds the amod milliseconds remaining mark updated until det timeout the amod timeout next nsubjpass updated timeout aux updated will auxpass updated be dep milliseconds updated param calls the collection of calls root ROOT calls nsubj calls param det collection the dobj calls collection case calls of nmod of collection calls return the number of calls which were timed out root ROOT return det number the dobj return number case calls of nmod of number calls nsubjpass timed calls ref calls which auxpass timed were acl relcl calls timed compound prt timed out int handle timeouts root ROOT handle dobj handle timeouts collection call calls string msg check failed ANTONYM ANTONYM check have ANTONYM ANTONYM check return ANTONYM ANTONYM failed return ANTONYM ANTONYM have removed ANTONYM ANTONYM have return ANTONYM ANTONYM next removed ANTONYM ANTONYM return number ANTONYM ANTONYM out failed SYNONYM SYNONYM;0
sets base starting line number for this script or function this is a one time operation and throws an exception if the line number has already been set public void set VBN base NN lineno NN int lineno NN sets base starting line number for this script or function root ROOT number compound number sets compound number base amod number starting compound number line case script for det script this nmod for number script cc script or nmod for number function conj or script function this is a one time operation and throws an exception if the root ROOT operation nsubj operation this nsubj throws this cop operation is det operation a nummod operation one compound operation time cc operation and conj and operation throws det exception an dobj operation exception case the if nmod if exception the line number has already been set root ROOT set compound number line nsubjpass set number aux set has advmod set already auxpass set been public void set base lineno root ROOT set compound lineno base dobj set lineno int lineno base set ANTONYM ANTONYM function operation ANTONYM ANTONYM number function ANTONYM ANTONYM or operation ANTONYM ANTONYM sets base ANTONYM ANTONYM starting function ANTONYM ANTONYM starting has ANTONYM ANTONYM;0
private resource NN config NN resource NN to TO resource NN config NN resource NN config NN resource NN private resource config resource to resource root ROOT resource compound resource config case resource to nmod to resource resource config resource root ROOT resource compound resource config config resource root ROOT resource compound resource config;0
create a self signed x certificate from http bfo com blog odds and ends creating a new x certificate html param dn the x distinguished name eg cn test l london c gb param pair the key pair param days how many days from now the certificate is valid for param algorithm the signing algorithm eg sha with rsa return the self signed certificate throws certificate exception thrown if a security error or an io error occurred public static x CC certificate NN generate VB certificate NN string NN dn NN key JJ pair NN pair NN int days NNS string NN algorithm NN throws certificate NN exception NN create a self signed x certificate root ROOT create det self a nsubj signed self ccomp create signed cc signed x ccomp create certificate conj x signed certificate from http bfo com blog odds and ends creating a new x certificate html root ROOT odds case odds from amod odds http compound odds bfo compound odds com compound odds blog cc odds and aux creating ends conj and odds creating det html a amod html new compound html x compound html certificate dobj creating html param dn the x distinguished name eg cn test l london c gb root ROOT dn nsubj dn param det x the dobj dn x amod name distinguished dep x name compound gb eg compound gb cn compound gb test compound gb l compound gb london compound gb c dep name gb param pair the key pair root ROOT pair compound pair param det pair the amod pair key dep pair pair param days how many days from now the certificate is valid for root ROOT days compound days param advmod many how amod days many dobj valid days case now from nmod from valid now det certificate the nsubj valid certificate cop valid is dep days valid dep valid for param algorithm the signing algorithm eg sha with rsa root ROOT algorithm compound algorithm param det algorithm the compound algorithm signing nsubj sha algorithm advmod sha eg acl relcl algorithm sha case rsa with nmod with sha rsa return the self signed certificate root ROOT signed csubj signed return det self the dobj return self dobj signed certificate throws certificate exception thrown if a security error or an io error occurred root ROOT throws compound exception certificate dobj throws exception acl exception thrown mark occurred if det error a compound error security nsubj occurred error cc error or det error an compound error io conj or error error nsubj occurred error advcl if thrown occurred public static x certificate root ROOT certificate compound certificate x generate certificate root ROOT generate dobj generate certificate string dn key pair root ROOT pair amod pair key pair int days string algorithm throws certificate exception root ROOT exception compound exception certificate create name ANTONYM ANTONYM create thrown ANTONYM ANTONYM create throws ANTONYM ANTONYM creating name ANTONYM ANTONYM creating thrown ANTONYM ANTONYM creating throws ANTONYM ANTONYM distinguished signing ANTONYM ANTONYM name is ANTONYM ANTONYM name thrown ANTONYM ANTONYM name throws ANTONYM ANTONYM return occurred ANTONYM ANTONYM return thrown ANTONYM ANTONYM return throws ANTONYM ANTONYM signed distinguished ANTONYM ANTONYM l c SYNONYM SYNONYM x c SYNONYM SYNONYM x l SYNONYM SYNONYM;0
public static final type NN nullable JJ string NN new type NN public static final type nullable string root ROOT string amod string nullable new type;0
public Long validate VB object NN item NN public Long validate object item;0
public Long read VB byte NN buffer NN buffer NN public Long read byte buffer root ROOT buffer compound buffer byte buffer;0
public integer NN validate VB object NN item NN public integer validate object item;0
public boolean has VBZ undrained VBN public boolean has undrained root ROOT undrained aux undrained has;0
boolean flush NN in IN progress NN boolean flush in progress root ROOT flush case progress in nmod in flush progress;0
returns true if the named property is defined as a const on this object param name return true if the named property is defined as a const false otherwise public boolean is VBZ const IN string NN name NN returns true if the named property is defined as a const on this object root ROOT returns amod returns true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const case object on det object this nmod on const object param name root ROOT name compound name param return true if the named property is defined as a const false root ROOT return amod return true mark defined if det property the amod property named nsubjpass defined property auxpass defined is advcl if true defined case const as det const a nmod as defined const amod const false otherwise public boolean is const root ROOT const cop const is string name is name ANTONYM ANTONYM named is ANTONYM ANTONYM true false ANTONYM ANTONYM;0
void abort VB undrained JJ batches NNS runtime NN exception NN reason NN void abort undrained batches root ROOT abort amod batches undrained dobj abort batches runtime exception root ROOT exception compound exception runtime reason;0
close this accumulator and force all the record buffers to be drained public void close RB close this accumulator and force all the record buffers to be drained root ROOT accumulator advmod accumulator close det accumulator this cc accumulator and conj and accumulator force det predet buffers all det buffers the compound buffers record dobj force buffers nsubjpass xsubj drained buffers mark drained to auxpass drained be xcomp force drained public void close close public ANTONYM ANTONYM;0
disconnects the connection to a particular node if there is one any pending client requests for this connection will receive disconnections param node id the id of the node override NN public void disconnect VB string NN node NN id NN disconnects the connection to a particular node if there is one root ROOT disconnects det connection the dobj disconnects connection case node to det node a amod node particular nmod to connection node mark is if expl is there advcl if disconnects is nsubj is one any pending client requests for this connection will receive disconnections root ROOT receive det requests any amod requests pending compound requests client nsubj receive requests case connection for det connection this nmod for requests connection aux receive will dobj receive disconnections param node id the id of the node root ROOT id compound node param nsubj id node det id the dobj id id case node of det node the nmod of id node override public void disconnect string node id root ROOT id compound id node connection disconnect ANTONYM ANTONYM connection disconnections ANTONYM ANTONYM connection disconnects ANTONYM ANTONYM;0
closes the connection to a particular node if there is one all requests on the connection will be cleared client request callbacks will not be invoked all requests on the connection will be cleared client request callbacks will not be invoked for the cleared requests nor will they be returned from poll param node id the id of the node override NN public void close RB string NN node NN id NN closes the connection to a particular node if there is one root ROOT closes det connection the dobj closes connection case node to det node a amod node particular nmod to connection node mark is if expl is there advcl if closes is nsubj is one all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked all requests on the connection will be cleared client request callbacks will not be invoked root ROOT cleared det requests all nsubjpass cleared requests case connection on det connection the nmod on requests connection aux cleared will auxpass cleared be compound callbacks client compound callbacks request nsubjpass invoked callbacks aux invoked will neg invoked not auxpass invoked be ccomp cleared invoked for the cleared requests nor will they be returned from poll root ROOT requests case requests for det requests the amod requests cleared cc requests nor aux returned will nsubjpass returned they auxpass returned be conj nor requests returned case poll from nmod from returned poll param node id the id of the node root ROOT id compound node param nsubj id node det id the dobj id id case node of det node the nmod of id node override public void close string node id root ROOT id compound id node cleared returned ANTONYM ANTONYM public close ANTONYM ANTONYM particular close SYNONYM SYNONYM;0
check if the node with the given id is ready to send more requests param node the node param now the current time in ms return true if the node is ready override NN public boolean is VBZ ready JJ node NN node NN long now RB check if the node with the given id is ready to send more requests root ROOT check mark ready if det node the nsubj ready node nsubj xsubj send node case id with det id the amod id given nmod with node id cop ready is advcl if check ready mark send to xcomp ready send amod requests more dobj send requests param node the node root ROOT node compound node param det node the dep node node param now the current time in ms root ROOT time nsubj time param advmod time now det time the amod time current case ms in nmod in time ms return true if the node is ready root ROOT return amod return true mark ready if det node the nsubj ready node cop ready is advcl if true ready override public boolean is ready root ROOT ready cop ready is node node long now check given ANTONYM ANTONYM check return ANTONYM ANTONYM given ready ANTONYM ANTONYM given send ANTONYM ANTONYM;0
queue up the given request for sending requests can only be sent out to ready nodes queue up the given request for sending requests can only be sent out to ready nodes param request the request param now the current timestamp override NN public void send VB client NN request NN request NN long now RB queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes queue up the given request for sending requests can only be sent out to ready nodes root ROOT sent csubjpass sent queue compound prt queue up det request the amod request given dobj queue request mark sending for acl for request sending dobj sending requests aux sent can advmod sent only auxpass sent be compound prt sent out case nodes to amod nodes ready nmod to sent nodes param request the request root ROOT request compound request param det request the dobj request request param now the current timestamp root ROOT timestamp compound timestamp param advmod timestamp now det timestamp the amod timestamp current override public void send client request root ROOT request compound request client request long now given ready ANTONYM ANTONYM given send ANTONYM ANTONYM given sending ANTONYM ANTONYM given sent ANTONYM ANTONYM up ready SYNONYM SYNONYM;0
handle any disconnected connections param responses the list of responses that completed with the disconnection param now the current time private void handle VB disconnections NNS list NN client NN response NN responses NNS long now RB handle any disconnected connections root ROOT handle det connections any amod connections disconnected dobj handle connections param responses the list of responses that completed with the disconnection root ROOT responses compound responses param det list the dep responses list case responses of nmod of list responses nsubj completed responses ref responses that acl relcl responses completed case disconnection with det disconnection the nmod with completed disconnection param now the current time root ROOT time nsubj time param advmod time now det time the amod time current private void handle disconnections root ROOT handle dobj handle disconnections list client response root ROOT response compound response client responses long now connections disconnection ANTONYM ANTONYM;0
public isolation NN level NN isolation NN level NN public isolation level root ROOT level compound level isolation isolation level root ROOT level compound level isolation;0
request NN and CC partition NN level NN name NN private static final string NN max NN bytes NNS key JJ name NN max NN bytes NNS request and partition level name private static final string max bytes key name root ROOT name compound name max compound name bytes amod name key max bytes root ROOT bytes compound bytes max;0
partition NN level NN field NN names NNS private static final string NN partition NN key JJ name NN partition NN partition level field names private static final string partition key name root ROOT name compound name partition amod name key partition;0
private int syntax NN error NN count NN private int syntax error count root ROOT count compound count syntax compound count error;0
public partition NN data NNS long fetch VB offset VBN long log NN start NN offset VBP int max NN bytes NNS public partition data root ROOT data compound data partition long fetch offset root ROOT fetch dep fetch offset long log start offset root ROOT offset compound start log nsubj offset start int max bytes root ROOT bytes compound bytes max;0
private k NN stream NN builder NN setup NN topology NN with IN intermediate JJ user NN topic NN final string NN output NN topic NN private k stream builder root ROOT builder compound builder k compound builder stream setup topology with intermediate user topic root ROOT topology compound topology setup case topic with amod topic intermediate compound topic user nmod with topology topic final string output topic root ROOT topic compound topic output;0
private final map NN string NN list NN partition NN info NN available JJ partitions NNS by IN topic NN private final map string list partition info root ROOT info compound info partition available partitions by topic root ROOT partitions amod partitions available case topic by nmod by partitions topic;0
private final map NN string NN list NN partition NN info NN partitions NNS by IN topic NN private final map string list partition info root ROOT info compound info partition partitions by topic root ROOT partitions case topic by nmod by partitions topic;0
private final set NN string NN internal JJ topics NNS private final set string internal topics root ROOT topics amod topics internal;0
public static cluster NN empty JJ public static cluster empty;0
public cluster NN with IN partitions NNS map NN topic NN partition NN partition NN info NN partitions NNS public cluster with partitions root ROOT partitions case partitions with map topic partition root ROOT partition compound partition topic partition info root ROOT info compound info partition partitions;0
public list NN node NN nodes NNS public list node nodes;0
public set NN string NN internal JJ topics NNS public set string internal topics root ROOT topics amod topics internal;0
public void inject VB authentication NN repository JJ system NN session NN session NN list NN artifact NN repository NN repositories NNS public void inject authentication root ROOT inject dobj inject authentication repository system session root ROOT session amod session repository compound session system session list artifact repository root ROOT repository compound repository artifact repositories;0
public node NN controller NN public node controller;0
protected void update VB sample NN sample NN metric JJ config NN config NN double value NN long now RB protected void update sample sample metric config root ROOT config amod config metric config double value long now;0
public double combine VB list NN sample NN samples NNS metric JJ config NN config NN long now RB public double combine list sample samples metric config root ROOT config amod config metric config long now;0
public count NN public count;0
public record NN metadata NN topic NN partition NN topic NN partition NN long base NN offset VBD long relative JJ offset VBN long timestamp NN Long checksum NN int serialized VBN key JJ size NN int serialized VBN value NN size NN public record metadata root ROOT metadata compound metadata record topic partition root ROOT partition compound partition topic topic partition root ROOT partition compound partition topic long base offset root ROOT offset nsubj offset base long relative offset root ROOT relative dep relative offset long timestamp Long checksum int serialized key size root ROOT serialized amod size key dobj serialized size int serialized value size root ROOT size amod size serialized compound size value;0
public int partition NN public int partition;0
private final int serialized VBN key JJ size NN private final int serialized key size root ROOT serialized amod size key dobj serialized size;0
public object NN get VB negotiated VBN property NN string NN prop VB name NN public object get negotiated property root ROOT get amod property negotiated dobj get property string prop name root ROOT prop dobj prop name;0
public boolean is VBZ complete JJ public boolean is complete root ROOT complete cop complete is;0
private static final string NN jaas NN user NN prefix NN user NN private static final string jaas user prefix root ROOT prefix compound prefix jaas compound prefix user user;0
gets the dependencies that could not be resolved return the unresolved dependencies never code null list NN dependency NN get VB unresolved JJ dependencies NNS gets the dependencies that could not be resolved root ROOT gets det dependencies the dobj gets dependencies nsubjpass resolved dependencies ref dependencies that aux resolved could neg resolved not auxpass resolved be acl relcl dependencies resolved return the unresolved dependencies never code null root ROOT return det dependencies the amod dependencies unresolved nsubj code dependencies neg code never ccomp return code dobj code null list dependency get unresolved dependencies root ROOT get amod dependencies unresolved dobj get dependencies gets return ANTONYM ANTONYM resolved unresolved ANTONYM ANTONYM;0
override NN public string NN get VB mechanism NN name NN override public string get mechanism name root ROOT get compound name mechanism dobj get name;0
visits this node then the test expression the true expression and the false expression override NN public void visit NN node NN visitor NN v LS visits this node then the test expression the true expression root ROOT visits det node this dobj visits node advmod expression then det expression the compound expression test nmod node expression det expression the amod expression true dep expression expression and the false expression root ROOT expression cc expression and det expression the amod expression false override public void visit node visitor root ROOT visitor compound visitor node v true false ANTONYM ANTONYM false void SYNONYM SYNONYM;0
override NN public boolean has VBZ side JJ effects NNS override public boolean has side effects root ROOT has amod effects side dobj has effects;0
public void set VBN colon NN position NN int colon NN position NN public void set colon position root ROOT set compound position colon dobj set position int colon position root ROOT position compound position colon;0
public int get VB colon NN position NN public int get colon position root ROOT get compound position colon dobj get position;0
public conditional JJ expression NN int pos NNS public conditional expression root ROOT expression amod expression conditional int pos;0
private ast IN node NN false JJ expression NN private ast node root ROOT node case node ast false expression root ROOT expression amod expression false;0
public live JJ connect VB drv NN string NN args NNS public live connect drv root ROOT live dep live connect dobj connect drv string args;0
public static void main JJ string NN args NNS public static void main string args;0
private maven NN metadata NN cache NN cache NN private maven metadata cache root ROOT cache compound cache maven compound cache metadata cache;0
read the contents of a file into a string public static string NN read VB file NN string NN file NN path NN read the contents of a file into a string root ROOT read det contents the dobj read contents case file of det file a nmod of contents file case string into det string a nmod into read string public static string read file root ROOT read dobj read file string file path root ROOT path compound path file read file ANTONYM ANTONYM;0
from IN the DT current JJ date NN return a DT string NN in IN the DT format NN dd NN mm NN yy NN where WRB is VBZ specified VBN by IN the DT separator NN argument NN public static string NN get VB current JJ date NN string NN separator NN from the current date return a string in the format dd mm yy root ROOT yy compound yy dd compound yy mm where is specified by the separator argument public static string get current date root ROOT get amod date current dobj get date string separator;0
public boolean sleep NN int ms NNS public boolean sleep int ms;0
file NN test NN directory NN file test directory root ROOT directory compound directory test;0
generates code to wrap java arguments into object non primitive java types are left as is pending conversion in the helper method leaves the array object on the top of the stack in the helper method leaves the array object on the top of the stack static void generate VB push NN wrapped VBN args NNS class NN file NN writer NN cfw NN Class arg NN types NNS int array NN length NN generates code to wrap java arguments into object root ROOT generates dobj generates code mark wrap to advcl to generates wrap compound arguments java dobj wrap arguments case object into nmod into wrap object non primitive java types are left as is pending conversion root ROOT left amod types non amod types primitive compound types java nsubjpass left types auxpass left are advmod conversion as cop conversion is amod conversion pending ccomp left conversion in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack in the helper method leaves the array object on the top of the stack root ROOT leaves case method in det method the compound method helper nmod in leaves method det object the compound object array dobj leaves object case top on det top the nmod on leaves top case the of nmod of top the dep leaves stack static void generate push wrapped args root ROOT generate compound args push amod args wrapped dobj generate args class file writer root ROOT writer compound writer class compound writer file cfw Class arg types root ROOT types compound types arg int array length root ROOT length compound length array generates leaves ANTONYM ANTONYM generates left ANTONYM ANTONYM leaves top ANTONYM ANTONYM left top ANTONYM ANTONYM;0
private static final int id NN java NN adapter NN private static final int id java adapter root ROOT adapter compound adapter id compound adapter java;0
Class interfaces NNS Class interfaces;0
java NN adapter NN signature NN Class super JJ class NN Class interfaces NNS obj NN to TO int VB map NN names NNS java adapter signature root ROOT signature compound signature java compound signature adapter Class super class root ROOT class amod class super Class interfaces obj to int map root ROOT obj mark int to acl to obj int dobj int map names;0
override NN public int hash VB code NN override public int hash code root ROOT hash dobj hash code;0
nodes NNS incident NN to TO this depend VB on IN me PRP list NN metadata NN graph NN node NN in IN nodes NNS nodes incident to this depend on me list metadata graph node root ROOT node compound node metadata compound node graph in nodes root ROOT nodes case nodes in;0
change the value of the internal flag that determines whether all storage is handed by a dense backing array rather than an associative store param dense only new value for dense only flag throws illegal argument exception if an attempt is made to enable dense only after it was disabled native array code is not written to handle switching back to a dense representation void set VBN dense JJ only RB boolean dense JJ only RB change the value of the internal flag that determines whether all root ROOT change det value the dobj change value case flag of det flag the amod flag internal nmod of value flag nsubj determines flag ref flag that acl relcl flag determines dobj determines whether det whether all storage is handed by a dense backing array rather than an associative root ROOT handed nsubjpass handed storage auxpass handed is case array by det array a amod array dense compound array backing nmod agent handed array cc array rather mwe rather than det associative an nmod agent handed associative conj negcc array associative store param dense only new value for dense only flag root ROOT value compound value param amod value dense advmod value only amod value new case flag for amod flag dense amod flag only nmod for value flag throws illegal argument exception if an attempt is made to enable root ROOT throws amod exception illegal compound exception argument dobj throws exception mark made if det attempt an nsubjpass made attempt nsubj xsubj enable attempt auxpass made is advcl if throws made mark enable to xcomp made enable dense only after it was disabled native array code is not written root ROOT written advmod written dense advmod code only mark code after nsubj code it cop code was amod code disabled amod code native compound code array nsubjpass written code auxpass written is neg written not to handle switching back to a dense representation root ROOT handle mark handle to dobj handle switching advmod handle back case representation to det representation a amod representation dense nmod to back representation void set dense only root ROOT set xcomp set dense advmod set only boolean dense only root ROOT dense advmod dense only change throws ANTONYM ANTONYM determines made ANTONYM ANTONYM enable disabled ANTONYM ANTONYM handed made ANTONYM ANTONYM handed throws ANTONYM ANTONYM is made ANTONYM ANTONYM made switching ANTONYM ANTONYM made was ANTONYM ANTONYM;0
private static void define VB elem NN context NN cx NN scriptable JJ target NN long index NN object NN value NN private static void define elem root ROOT define dobj define elem context cx scriptable target long index object value;0
private static void set VBN elem NNS context NN cx NN scriptable JJ target NN long index NN object NN value NN private static void set elem root ROOT set dobj set elem context cx scriptable target long index object value;0
public object NN remove VB int index NN public object remove int index;0
internal representation of the java script array s length property private long length NN internal representation of the java script array s length property root ROOT s amod representation internal nsubj s representation case array of det array the compound array java compound array script nmod of representation array compound property length dobj s property private long length internal private SYNONYM SYNONYM;0
the default capacity for code dense code private static final int default NN initial JJ capacity NN the default capacity for code dense code root ROOT capacity det capacity the compound capacity default case code for compound code code amod code dense nmod for capacity code private static final int default initial capacity root ROOT capacity compound capacity default amod capacity initial initial final ANTONYM ANTONYM;0
private static final int max NN pre JJ grow VB size NN int integer NN max NN value NN grow VB factor NN private static final int max pre grow size root ROOT max amod max pre dep pre grow dobj grow size int integer max root ROOT max compound max integer value grow factor root ROOT grow dobj grow factor;0
public int hash VB code NN public int hash code root ROOT hash dobj hash code;0
public int index NN of IN object NN o NN public int index of root ROOT index acl index of object o;0
public void set VBN flags NNS string NN flags NNS public void set flags root ROOT set dobj set flags string flags;0
override NN public string NN to TO source NN int depth NN override public string to source root ROOT source case source to int depth;0
private string NN js NNS to TO source NN private string js to source root ROOT js case source to nmod to js source;0
private namespace NN construct NN namespace NN private namespace construct namespace root ROOT namespace compound namespace construct;0
namespace NN cast VBN to TO namespace VB object NN namespace NN obj NN namespace cast to namespace root ROOT cast mark namespace to xcomp cast namespace object namespace obj root ROOT obj compound obj namespace;0
override NN public string NN get VB class NN name NN override public string get class name root ROOT get compound name class dobj get name;0
public string NN to TO locale NN string NN public string to locale string root ROOT string case string to compound string locale;0
checks the url to see if this repository refers to an external repository param original repository return true if external static boolean is VBZ external JJ repo NN artifact NN repository NN original JJ repository NN checks the url to see if this repository refers to an external repository root ROOT checks det url the dobj checks url mark see to acl to url see mark refers if det repository this nsubj refers repository advcl if see refers case repository to det repository an amod repository external nmod to refers repository param original repository root ROOT repository compound repository param amod repository original return true if external root ROOT return amod return true mark external if advcl if true external static boolean is external repo root ROOT repo cop repo is amod repo external artifact repository root ROOT repository compound repository artifact original repository root ROOT repository amod repository original checks return ANTONYM ANTONYM;0
private cache NN cache NN parent NN private cache cache parent;0
private simple JJ date NN format NN formatter NN private simple date format root ROOT format amod format simple compound format date formatter;0
first RB second JJ contained VBN in IN cache NN private long first RB Long MIN value NN first second contained in cache private long first Long MIN value second min ANTONYM ANTONYM;0
last JJ second JJ contained VBN in IN cache NN private long last JJ Long MIN value NN last second contained in cache private long last Long MIN value last second ANTONYM ANTONYM second min ANTONYM ANTONYM;0
index NN of IN first RB in IN the DT cyclic JJ cache NN private int offset VBN index of first in the cyclic cache private int offset;0
helper NN object NN to TO be VB able JJ to TO call NN simple JJ date NN format NN format NN private final date NN current JJ date NN new date NN helper object to be able to call simple date format format root ROOT format amod format simple compound format date compound format format private final date current date root ROOT date amod date current new date;0
binds a new name to the object bound to an old name and unbinds the old name param old name the name of the existing binding may not be empty param new name the name of the new binding may not be empty exception name already bound exception if new name is already bound exception naming exception if a naming exception is encountered override NN public void rename VB string NN old JJ name NN string NN new JJ name NN throws naming VBG exception NN binds a new name to the object bound to an old name and unbinds the root ROOT bound csubj bound binds csubj unbinds binds det name a amod name new dobj binds name case object to det object the nmod to binds object case name to det name an amod name old nmod to bound name cc bound and conj and bound unbinds dobj unbinds the old name root ROOT name amod name old param old name the name of the existing binding may not be empty root ROOT empty compound name param amod name old dobj empty name det name the nsubj empty name case binding of det binding the amod binding existing nmod of name binding aux empty may neg empty not cop empty be param new name the name of the new binding may not be empty root ROOT param amod name new dobj param name det name the nsubj empty name case binding of det binding the amod binding new nmod of name binding aux empty may neg empty not cop empty be acl relcl name empty exception name already bound exception if new name is already bound root ROOT bound compound name exception nsubj bound name advmod bound already dobj bound exception mark bound if amod name new nsubjpass bound name auxpass bound is advmod bound already advcl if bound bound exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public void rename string old name root ROOT name amod name old string new name root ROOT name amod name new throws naming exception root ROOT naming dobj naming exception be naming ANTONYM ANTONYM binding throws ANTONYM ANTONYM binds throws ANTONYM ANTONYM binds unbinds ANTONYM ANTONYM is naming ANTONYM ANTONYM name be ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM new old ANTONYM ANTONYM unbinds binding ANTONYM ANTONYM;0
public void set VBN global JJ update VBP policy NN string NN update VB policy NN public void set global update policy root ROOT set xcomp set global dep set update dobj update policy string update policy root ROOT update dobj update policy;0
enumerates the names bound in the named context along with the class names of objects bound to them param name the name of the context to list return an enumeration of the names and class names of the bindings in this context each element of the enumeration is of type name class pair this context each element of the enumeration is of type name class pair exception naming exception if a naming exception is encountered override NN public naming VBG enumeration NN name NN class NN pair NN list NN string NN name NN throws naming VBG exception NN enumerates the names bound in the named context along with the class root ROOT enumerates det names the dobj enumerates names acl names bound case context in det context the amod context named nmod in bound context case class along mwe along with det class the nmod along with names class names of objects bound to them root ROOT names case objects of nmod of names objects acl objects bound case them to nmod to bound them param name the name of the context to list root ROOT name compound name param det name the dep name name case context of det context the nmod of name context case list to nmod to name list return an enumeration of the names and class names of the bindings in root ROOT return det enumeration an dobj return enumeration case names of det names the nmod of enumeration names cc names and compound names class nmod of enumeration names conj and names names case bindings of det bindings the nmod of names bindings dep return in this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class this context each element of the enumeration is of type name class pair root ROOT pair det context this nmod tmod pair context det element each nsubj pair element case enumeration of det enumeration the nmod of element enumeration cop pair is case pair of compound pair type compound pair name compound pair class exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public naming enumeration root ROOT naming dobj naming enumeration name class pair root ROOT pair compound pair name compound pair class list string name throws naming exception root ROOT naming dobj naming exception enumerates list ANTONYM ANTONYM is naming ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM names is ANTONYM ANTONYM names throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM return throws ANTONYM ANTONYM;0
retrieves the named object following links except for the terminal atomic component of the name if the object bound to name is not a atomic component of the name if the object bound to name is not a link returns the object itself param name the name of the object to look up return the object bound to name not following the terminal link if any exception naming exception if a naming exception is encountered override NN public object NN lookup NN link NN name NN name NN throws naming VBG exception NN retrieves the named object following links except for the terminal root ROOT retrieves det object the amod object named dobj retrieves object case links following nmod following retrieves links case terminal except mwe except for det terminal the nmod except for links terminal atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not atomic component of the name if the object bound to name is not a root ROOT a amod component atomic nsubj a component case name of det name the nmod of component name mark bound if det object the nsubj bound object csubj a bound case name to nmod to bound name cop a is neg a not link returns the object itself root ROOT returns nsubj returns link det object the dobj returns object nmod npmod returns itself param name the name of the object to look up root ROOT name compound name param det name the dep name name case object of det object the nmod of name object mark look to acl to name look compound prt look up return the object bound to name not following the terminal link root ROOT return det object the nsubj bound object nsubj xsubj name object ccomp return bound mark name to xcomp bound name neg following not xcomp name following det link the amod link terminal dobj following link if any root ROOT any mark any if exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public object lookup link root ROOT link compound link lookup name name throws naming exception root ROOT naming dobj naming exception is naming ANTONYM ANTONYM look encountered ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM naming throws ANTONYM ANTONYM retrieves encountered ANTONYM ANTONYM retrieves return ANTONYM ANTONYM retrieves returns ANTONYM ANTONYM return throws ANTONYM ANTONYM returns throws ANTONYM ANTONYM;0
protected boolean is VBZ writable JJ protected boolean is writable root ROOT writable cop writable is;0
release the lock for the given mutex param mutex the mutex from which to release the lock return the operation status public static native int unlock NN long mutex NN release the lock for the given mutex root ROOT release det lock the dobj release lock case mutex for det mutex the amod mutex given nmod for release mutex param mutex the mutex from which to release the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod from release mutex case which from ref mutex which mark release to acl relcl mutex release det lock the dobj release lock return the operation status root ROOT return det status the compound status operation dobj return status public static native int unlock long mutex lock unlock ANTONYM ANTONYM release given ANTONYM ANTONYM;0
destroy the mutex and free the memory associated with the lock param mutex the mutex to destroy return the operation status public static native int destroy VB long mutex NN destroy the mutex and free the memory associated with the lock root ROOT destroy det mutex the dobj destroy mutex cc mutex and amod memory free det memory the dobj destroy memory conj and mutex memory acl mutex associated case lock with det lock the nmod with associated lock param mutex the mutex to destroy root ROOT mutex compound mutex param det mutex the dep mutex mutex mark destroy to acl to mutex destroy return the operation status root ROOT return det status the compound status operation dobj return status public static native int destroy long mutex lock free ANTONYM ANTONYM;0
public static native string NN defname NN public static native string defname;0
public static final int apr NN lock NN flock NN flock NN public static final int apr lock flock root ROOT flock compound flock apr compound flock lock flock;0
public static final int apr NN lock NN default NN use NN the DT default process NN lock NN public static final int apr lock default root ROOT default compound default apr compound default lock use the default process lock;0
acquire the lock for the given mutex if the mutex is already locked acquire the lock for the given mutex if the mutex is already locked the current thread will be put to sleep until the lock becomes available param mutex the mutex on which to acquire the lock return the operation status public static native int lock NN long mutex NN acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked acquire the lock for the given mutex if the mutex is already locked root ROOT acquire det lock the dobj acquire lock case mutex for det mutex the amod mutex given nmod for lock mutex mark locked if det mutex the nsubjpass locked mutex auxpass locked is advmod locked already advcl if acquire locked the current thread will be put to sleep until the lock becomes available root ROOT put det thread the amod thread current nsubjpass put thread nsubj xsubj sleep thread aux put will auxpass put be mark sleep to xcomp put sleep mark becomes until det lock the nsubj becomes lock advcl until sleep becomes xcomp becomes available param mutex the mutex on which to acquire the lock root ROOT mutex compound mutex param det mutex the dep mutex mutex nmod on acquire mutex case which on ref mutex which mark acquire to acl relcl mutex acquire det lock the dobj acquire lock return the operation status root ROOT return det status the compound status operation dobj return status public static native int lock long mutex acquire becomes ANTONYM ANTONYM given acquire ANTONYM ANTONYM given put ANTONYM ANTONYM given will ANTONYM ANTONYM;0
determine if pool a is an ancestor of pool b param a the pool to search param b the pool to search for return true if a is an ancestor of b null is considered an ancestor of all pools public static native boolean is VBZ ancestor NN long a DT long b NN determine if pool a is an ancestor of pool b root ROOT determine mark ancestor if compound a pool nsubj ancestor a cop ancestor is det ancestor an advcl if determine ancestor case b of compound b pool nmod of ancestor b param a the pool to search root ROOT param det pool a det pool the dobj param pool mark search to acl to pool search param b the pool to search for root ROOT b compound b param det pool the dep b pool mark search to acl to pool search nmod search for return true if a is an ancestor of b null is considered an ancestor root ROOT considered nsubjpass considered return amod return true mark ancestor if nsubj ancestor a cop ancestor is det ancestor an advcl if true ancestor case null of compound null b nmod of ancestor null auxpass considered is det ancestor an xcomp considered ancestor of all pools root ROOT pools case pools of det pools all public static native boolean is ancestor root ROOT ancestor cop ancestor is long a long b determine considered ANTONYM ANTONYM;0
public void set VBN global JJ checksum NN policy NN string NN checksum NN policy NN public void set global checksum policy root ROOT set amod policy global compound policy checksum dobj set policy string checksum policy root ROOT policy compound policy checksum;0
clear all memory in the pool and run all the cleanups this also destroys all clear all memory in the pool and run all the cleanups this also destroys all subpools param pool the pool to clear this does not actually free the memory it just allows the pool to re use this memory for the next allocation public static native void clear JJ long pool NN clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all subpools param pool the pool to clear root ROOT pool compound pool param det pool the dep pool pool case clear to nmod to pool clear this does not actually free the memory it just allows the pool root ROOT free nsubj free this aux free does neg free not advmod free actually det memory the dobj free memory nsubj allows it advmod allows just acl relcl memory allows det pool the dobj allows pool to re use this memory for the next allocation root ROOT re mark re to dobj re use det memory this dobj use memory case allocation for det allocation the amod allocation next nmod for use allocation public static native void clear long pool clear does ANTONYM ANTONYM clear free ANTONYM ANTONYM clear just ANTONYM ANTONYM clear run ANTONYM ANTONYM does use ANTONYM ANTONYM free allows ANTONYM ANTONYM free use ANTONYM ANTONYM public clear ANTONYM ANTONYM run does ANTONYM ANTONYM clear native SYNONYM SYNONYM in next SYNONYM SYNONYM;0
create a new pool param parent the parent pool if this is the new pool is a root param parent the parent pool if this is the new pool is a root pool if it is non zero the new pool will inherit all pool if it is non zero the new pool will inherit all of its parent pool s attributes except the apr pool t will be a sub pool return the pool we have just created public static native long create VB long parent NN create a new pool root ROOT create det pool a amod pool new dobj create pool param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a param parent the parent pool if this is the new pool is a root root ROOT root compound parent param nsubj root parent det pool the compound pool parent dep parent pool mark pool if nsubj pool this cop pool is det pool the amod pool new csubj root pool cop root is det root a pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all pool if it is non zero the new pool will inherit all root ROOT inherit nsubj inherit pool mark non if nsubj non it cop non is advcl if pool non nummod pool zero det pool the amod pool new dobj non pool aux inherit will dobj inherit all of its parent pool s attributes except the apr pool t will root ROOT s case s of nmod poss s its compound s parent compound s pool acl s attributes case t except det t the compound t apr compound t pool nmod except attributes t dep s will be a sub pool root ROOT pool cop pool be det pool a compound pool sub return the pool we have just created root ROOT created dep created return det pool the dobj return pool nsubj created we aux created have advmod created just public static native long create long parent create have ANTONYM ANTONYM have created ANTONYM ANTONYM just new ANTONYM ANTONYM return have ANTONYM ANTONYM zero all ANTONYM ANTONYM;0
public void set VBN adapter NN adapter NN adapter NN public void set adapter root ROOT set dobj set adapter adapter adapter;0
protected void set VBN error NN state NN error NN state NN error NN state NN throwable JJ t NN protected void set error state root ROOT set compound state error dobj set state error state root ROOT state compound state error error state root ROOT state compound state error throwable t;0
public abstract JJ processor NN abstract JJ endpoint NN endpoint NN public abstract processor root ROOT processor amod processor abstract abstract endpoint root ROOT endpoint amod endpoint abstract endpoint;0
private error NN state NN error NN state NN error NN state NN none NN private error state root ROOT state compound state error error state root ROOT state compound state error error state none root ROOT none compound none error compound none state;0
override NN public boolean is VBZ async NN override public boolean is async root ROOT async cop async is;0
protected executor NN get VB executor NN protected executor get executor root ROOT get dobj get executor;0
private abstract JJ processor NN abstract JJ endpoint NN endpoint NN request NN coyote NN request NN response NN coyote NN response NN private abstract processor root ROOT processor amod processor abstract abstract endpoint root ROOT endpoint amod endpoint abstract endpoint request coyote request root ROOT request compound request coyote response coyote response root ROOT response compound response coyote;0
public void action NN action NN code NN action NN code NN object NN param NN public void action action code root ROOT code compound code action action code root ROOT code compound code action object param;0
private final set NN string NN q VB names NNS new hash JJ set NN private final set string q names root ROOT q dobj q names new hash set root ROOT set amod set hash;0
public response NN get VB response NN public response get response root ROOT get dobj get response;0
public message NN bytes NNS content JJ type NN public message bytes root ROOT bytes compound bytes message content type root ROOT type amod type content;0
public message NN bytes NNS remote JJ addr NN public message bytes root ROOT bytes compound bytes message remote addr root ROOT addr amod addr remote;0
public void set VBN read NN listener NN read VB listener NN listener NN public void set read listener root ROOT set compound listener read dobj set listener read listener root ROOT read dobj read listener listener;0
private boolean expectation NN false JJ private boolean expectation false;0
private long content JJ length NN private long content length root ROOT length amod length content;0
private final u NN decoder NN url NN decoder NN new u NN decoder NN private final u decoder root ROOT decoder compound decoder u url decoder root ROOT decoder compound decoder url new u decoder root ROOT decoder compound decoder u;0
private final map NN string NN string NN path NN parameters NNS new hash VB map NN  private final map string string path parameters root ROOT parameters compound parameters path new hash map root ROOT hash dobj hash map;0
public void clear JJ public void clear public clear ANTONYM ANTONYM;0
first RB element NN of IN the DT queue NN protected entry NN first RB first element of the queue protected entry first;0
maximum NN size NN of IN the DT queue NN private final int max NN size NN maximum size of the queue private final int max size root ROOT size compound size max;0
private final entry NN get VB previous JJ private final entry get previous root ROOT get xcomp get previous;0
final int ord NN final int ord;0
long fp NN end NN long fp end root ROOT end compound end fp;0
byte stat NN bytes NNS new byte byte stat bytes root ROOT bytes compound bytes stat new byte;0
byte floor NN data NNS new byte byte floor data root ROOT data compound data floor new byte;0
byte suffix NN bytes NNS new byte byte suffix bytes root ROOT bytes compound bytes suffix new byte;0
int prefix NN int prefix;0
true JJ if all DT entries NNS are VBP terms NNS boolean is VBZ leaf NN block NN true if all entries are terms boolean is leaf block root ROOT block cop block is compound block leaf;0
public static final int version NN current JJ public static final int version current root ROOT current compound current version;0
private int bloom NN size NN private int bloom size root ROOT size compound size bloom;0
records a value in the set the referenced bytes are hashed and then modulo n d where n is the records a value in the set the referenced bytes are hashed and then modulo n d where n is the chosen size of the internal bitset param value the key value to be hashed throws io exception if there is a low level i o error public void add VB value NN bytes NNS ref VBP value NN throws io NN exception NN records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the records a value in the set the referenced bytes are hashed and then modulo n d where n is the root ROOT records det value a dobj records value case set in det set the nmod in hashed set det bytes the amod bytes referenced nsubjpass hashed bytes auxpass hashed are dep value hashed cc hashed and advmod d then compound d modulo compound d n dep value d conj and hashed d advmod the where nsubj the n cop the is acl relcl d the chosen size of the internal bitset root ROOT size amod size chosen case bitset of det bitset the amod bitset internal nmod of size bitset param value the key value to be hashed root ROOT value compound value param det value the amod value key dep value value mark hashed to auxpass hashed be acl to value hashed throws io exception if there is a low level i o error root ROOT throws compound exception io dobj throws exception mark is if expl is there advcl if throws is det level a amod level low nsubj is level compound error i compound error o dep level error public void add value root ROOT add dobj add value bytes ref root ROOT ref nsubj ref bytes value throws io exception root ROOT exception compound exception io d key ANTONYM ANTONYM i key ANTONYM ANTONYM level set ANTONYM ANTONYM public internal ANTONYM ANTONYM d i SYNONYM SYNONYM;0
public long ram NN bytes NNS used VBN public long ram bytes used root ROOT used compound bytes ram nsubj used bytes;0
public boolean is VBZ saturated VBN fuzzy JJ set NN bloom NN filter NN field NN info NN field NN info NN public boolean is saturated root ROOT saturated auxpass saturated is fuzzy set root ROOT set amod set fuzzy bloom filter root ROOT filter compound filter bloom field info root ROOT info compound info field field info root ROOT info compound info field;0
public int size NN public int size;0
public void check NN integrity NN throws io NN exception NN public void check integrity root ROOT integrity compound integrity check throws io exception root ROOT exception compound exception io;0
private final list NN field NN meta NN data NNS fields NNS new array NN list NN private final list field meta data root ROOT data compound data field compound data meta fields new array list root ROOT list compound list array;0
reused VBN in IN write VB blocks NNS private final list NN pending VBG block NN new JJ blocks NNS new array NN list NN reused in write blocks root ROOT write dobj write blocks private final list pending block root ROOT block amod block pending new blocks root ROOT blocks amod blocks new new array list root ROOT list compound list array;0
private pending VBG term NN first RB pending VBG term NN private pending term root ROOT term amod term pending first pending term root ROOT term advmod term first amod term pending;0
private pending VBG term NN last JJ pending JJ term NN private pending term root ROOT term amod term pending last pending term root ROOT term amod term last amod term pending;0
public void finish NN doc NN throws io NN exception NN public void finish doc root ROOT doc compound doc finish throws io exception root ROOT exception compound exception io;0
private long last JJ encoded VBN version NN private long last encoded version root ROOT version amod version last amod version encoded;0
public void encode VBP term NN long longs NNS data NNS output NN out IN field NN info NN field NN info NN block NN term NN state NN state NN boolean absolute JJ throws io NN exception NN public void encode term root ROOT encode dobj encode term long longs data output root ROOT output compound output data out field info root ROOT info compound info field field info root ROOT info compound info field block term state root ROOT state compound state block compound state term state boolean absolute throws io exception root ROOT exception compound exception io;0
public boolean has VBZ freqs NNS public boolean has freqs root ROOT has dobj has freqs;0
override NN public boolean has VBZ offsets NNS override public boolean has offsets root ROOT has dobj has offsets;0
override NN public boolean has VBZ positions NNS override public boolean has positions root ROOT has dobj has positions;0
override NN public boolean has VBZ payloads NNS override public boolean has payloads root ROOT has dobj has payloads;0
public long get VB sum NN total JJ term NN freq NN public long get sum total term freq root ROOT get compound freq sum amod freq total compound freq term dobj get freq;0
public long get VB sum NN doc NN freq NN public long get sum doc freq root ROOT get compound freq sum compound freq doc dobj get freq;0
public int get VB doc NN count NN public int get doc count root ROOT get compound count doc dobj get count;0
public long ram NN bytes NNS used VBN public long ram bytes used root ROOT used compound bytes ram nsubj used bytes;0
override NN public boolean is VBZ new JJ fragment NN override public boolean is new fragment root ROOT fragment cop fragment is amod fragment new;0
int frag NN num NN int frag num root ROOT num compound num frag;0
public v LS set VBN value NN v LS value NN public v set value root ROOT set dobj set value v value;1
public k NN set VBN key NN k NN key NN public k set key root ROOT set dobj set key k key k key ANTONYM ANTONYM;1
private void to TO exponential JJ format NN int first RB digit NN int dec NN point NN private void to exponential format root ROOT format case format to amod format exponential int first digit root ROOT digit advmod digit first int dec point root ROOT point compound point dec;1
final int get VB attributes NNS int id NN final int get attributes root ROOT get dobj get attributes int id;1
public int get VB attributes NNS string NN name NN public int get attributes root ROOT get dobj get attributes string name;1
private byte name NN null JJ private byte name null;1
private static final list NN string NN empty JJ string NN collections NNS empty JJ list NN private static final list string empty string root ROOT string amod string empty collections empty list root ROOT list compound list collections amod list empty;1
string NN is VBZ strict JJ org NN apache NN maven NN artifact NN repository JJ metadata NN io NN is VBZ strict JJ string is strict root ROOT strict cop strict is org apache maven artifact repository metadata io is strict root ROOT strict compound io org compound io apache compound io maven compound io artifact amod io repository compound io metadata nsubj strict io cop strict is;1
private short its PRP$ flags NNS private short its flags root ROOT flags nmod poss flags its;1
public string NN is VBZ scripting VBG invalid JJ public string is scripting invalid root ROOT scripting aux scripting is xcomp scripting invalid;1
private final boolean classes NNS private final boolean classes;1
private static final string NN odt NN file NN private static final string NN odt NN file NN private static final string odt file root ROOT file compound file odt private static final string odt file root ROOT file compound file odt;1
private static final string NN odt NN file NN with IN metadata NN private static final string odt file with metadata root ROOT file compound file odt case metadata with nmod with file metadata;1
private static final string NN odt NN file NN with IN min NN text NN len NN private static final string odt file with min text len root ROOT file compound file odt case len with compound len min compound len text nmod with file len;1
private static final string NN pdf NN zip NN file NN private static final string pdf zip file root ROOT file compound file pdf compound file zip;1
private final boolean methods NNS private final boolean methods;1
private static final string NN pdf NN file NN private static final string pdf file root ROOT file compound file pdf;1
private static final list NN string NN odt NN file NN private static final list string odt file root ROOT file compound file odt;1
abstract builder NN k NN v LS set VBN configuration NN serializable JJ configuration NN configuration NN abstract builder k v set configuration root ROOT set dobj set configuration serializable configuration root ROOT configuration amod configuration serializable configuration k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN key JJ translation NN function NN simple JJ function NN k NN function NN abstract builder k v set key translation function root ROOT set amod function key compound function translation dobj set function simple function root ROOT function amod function simple k function k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN value NN translation NN function NN simple JJ function NN v LS function NN abstract builder k v set value translation function root ROOT set compound function value compound function translation dobj set function simple function root ROOT function amod function simple v function k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN key JJ type NN descriptor NN type NN descriptor NN k NN key JJ type NN descriptor NN abstract builder k v set key type descriptor root ROOT set amod descriptor key compound descriptor type dobj set descriptor type descriptor root ROOT descriptor compound descriptor type k key type descriptor root ROOT descriptor amod descriptor key compound descriptor type k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN value NN type NN descriptor NN type NN descriptor NN v LS value NN type NN descriptor NN abstract builder k v set value type descriptor root ROOT set compound descriptor value compound descriptor type dobj set descriptor type descriptor root ROOT descriptor compound descriptor type v value type descriptor root ROOT descriptor compound descriptor value compound descriptor type k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN input NN format NN class NN type NN descriptor NN input NN format NN class NN abstract builder k v set input format class root ROOT set compound class input compound class format dobj set class type descriptor root ROOT descriptor compound descriptor type input format class root ROOT class compound class input compound class format k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN input NN format NN key JJ class NN type NN descriptor NN input NN format NN key JJ class NN abstract builder k v set input format key class root ROOT set compound class input compound class format amod class key dobj set class type descriptor root ROOT descriptor compound descriptor type input format key class root ROOT class compound class input compound class format amod class key k v SYNONYM SYNONYM;1
abstract builder NN k NN v LS set VBN input NN format NN value NN class NN type NN descriptor NN input NN format NN value NN class NN abstract builder k v set input format value class root ROOT set compound class input compound class format compound class value dobj set class type descriptor root ROOT descriptor compound descriptor type input format value class root ROOT class compound class input compound class format compound class value k v SYNONYM SYNONYM;1
private int successes NNS private int successes;1
private table NN reference NN set VBN default NN project NN if IN absent JJ private table reference root ROOT reference compound reference table set default project if absent root ROOT project amod project set compound project default mark absent if dep project absent;1
abstract builder NN t NN set VBN max NN files NNS per IN bundle NN integer NN max NN files NNS per IN bundle NN abstract builder t set max files per bundle root ROOT set compound files max dobj set files case bundle per nmod per files bundle integer max files per bundle root ROOT files compound files max case bundle per nmod per files bundle;1
abstract builder NN t NN set NN method NN method NN method NN abstract builder t set method root ROOT method compound method set method method;1
private static final string NN gearpump NN serializers NNS gearpump NN serializers NNS private static final string gearpump serializers root ROOT serializers compound serializers gearpump gearpump serializers root ROOT serializers compound serializers gearpump;1
private final string NN args NNS private final string args;1
static final string NN expected VBN result NN static final string expected result root ROOT result amod result expected;1
protected static final list NN serializable JJ function NN instant NN instant NN identity NN immutable JJ list NN serializable JJ function NN instant NN instant NN of IN protected static final list serializable function root ROOT function amod function serializable instant instant identity immutable list root ROOT list amod list immutable serializable function root ROOT function amod function serializable instant instant of;1
called when a new or active window is now known to be active ensure that if it is new then it becomes active with itself as its only state address window void ensure VB window NN is VBZ active JJ w NN window NN called when a new or active window is now known to be active root ROOT called advmod known when det window a amod window new cc new or conj or new active amod window active nsubjpass known window nsubj xsubj active window auxpass known is advmod known now advcl called known mark active to cop active be xcomp known active ensure that if it is new then it becomes active with itself as its only state address root ROOT ensure mark becomes that mark new if nsubj new it cop new is advcl if becomes new advmod becomes then nsubj becomes it ccomp ensure becomes xcomp becomes active case itself with nmod with active itself case address as nmod poss address its amod address only compound address state nmod as becomes address window void ensure window is active root ROOT active csubj active ensure dobj ensure window cop active is w window is known ANTONYM ANTONYM known be ANTONYM ANTONYM;1
void ensure VB window NN exists VBZ w NN window NN void ensure window exists root ROOT exists csubj exists ensure dobj ensure window w window;1
private static final string NN proto NN extension NN hosts NNS proto NN extension NN hosts NNS private static final string proto extension hosts root ROOT hosts compound hosts proto compound hosts extension proto extension hosts root ROOT hosts compound hosts proto compound hosts extension;1
auto NN prefix NN terms NNS public static final int version NN auto NN prefix NN terms NNS auto prefix root ROOT prefix compound prefix auto terms public static final int version auto prefix terms root ROOT terms compound terms version compound terms auto compound terms prefix;1
final boolean any DT auto NN prefix NN terms NNS final boolean any auto prefix terms root ROOT terms det terms any compound terms auto compound terms prefix;1
private final terms NNS enum VBP with IN slice NN top NN private final terms enum with slice root ROOT enum nsubj enum terms case slice with nmod with enum slice top;1
minimum NN per IN dim NN values NNS packed JJ protected final byte min NN packed VBD value NN minimum per dim root ROOT dim case dim per values packed protected final byte min packed value root ROOT packed nsubj packed min dobj packed value;1
maximum NN per IN dim NN values NNS packed JJ protected final byte max NN packed VBD value NN maximum per dim root ROOT dim case dim per values packed protected final byte max packed value root ROOT packed nsubj packed max dobj packed value;1
final byte scratch NN final byte scratch;1
private final fixed VBN bit NN set NN result NN private final fixed bit set root ROOT set amod set fixed compound set bit result;1
protected list NN query NN node NN set VBN children NNS order NN list NN query NN node NN children NNS throws query NN node NN exception NN protected list query node root ROOT node compound node query set children order root ROOT set compound order children dobj set order list query node root ROOT node compound node query children throws query node exception root ROOT exception compound exception query compound exception node;1
protected final bit NN set NN is VBZ internal JJ edges NNS protected final bit set root ROOT set compound set bit is internal edges root ROOT edges cop edges is amod edges internal;1
private static final string NN is VBZ internal JJ key JJ name NN is VBZ internal JJ private static final string is internal key name root ROOT name cop name is amod name internal amod name key is internal root ROOT internal cop internal is is name ANTONYM ANTONYM internal private SYNONYM SYNONYM;1
private final static string NN creations NNS creations NNS private final static string creations creations;1
public long get VB clicks NNS public long get clicks root ROOT get dobj get clicks;1
public string NN is VBZ xml NN public string is xml root ROOT xml cop xml is;1
private final int days NNS private final int days;1
public static final type NN records NNS new type NN public static final type records new type;1
validate that the partition exists on the cluster param topic partition partition to validate param store name name of the store the partition is for throws org apache kafka streams errors streams exception if partition doesn t exist void validate VB partition NN exists VBZ final topic NN partition NN topic NN partition NN final string NN store NN name NN validate that the partition exists on the cluster root ROOT validate mark exists that det partition the nsubj exists partition ccomp validate exists case cluster on det cluster the nmod on exists cluster param topic partition partition to validate root ROOT partition compound partition param compound partition topic compound partition partition mark validate to acl to partition validate param store name name of the store the partition is for root ROOT name compound name param compound name store compound name name case store of det store the nmod of name store det partition the nsubj for partition cop for is acl relcl store for throws org apache kafka streams errors streams exception if partition doesn t exist root ROOT throws advmod apache org amod exception apache compound exception kafka compound exception streams compound exception errors compound exception streams dobj throws exception mark exist if compound t partition compound t doesn nsubj exist t advcl if throws exist void validate partition exists root ROOT exists csubj exists validate dobj validate partition final topic partition root ROOT partition compound partition topic topic partition root ROOT partition compound partition topic final string store name root ROOT name compound name store name is ANTONYM ANTONYM name throws ANTONYM ANTONYM validate void ANTONYM ANTONYM;1
for each class file in the suite directory create a test file object for live connect the test class name needs to be the name of the class and the file path needs to be the full package name prepended with the java script keyword packages and without the class suffix java script keyword packages and without the class suffix public void get VB cases NNS test NN suite NN suite NN for each class file in the suite directory create a test file object root ROOT create case file for det file each compound file class nmod for create file case directory in det directory the compound directory suite nmod in file directory det object a compound object test compound object file dobj create object for live connect the test class name needs to be the name of the class root ROOT connect mark connect for nsubj connect live det name the compound name test compound name class nsubj needs name nsubj xsubj name name ccomp connect needs mark name to cop name be det name the xcomp needs name case class of det class the nmod of name class and the file path needs to be the full package name prepended with the root ROOT needs cc needs and det path the compound path file nsubj needs path nsubj xsubj name path mark name to cop name be det name the amod name full compound name package xcomp needs name acl name prepended case the with nmod with prepended the java script keyword packages and without the class suffix root ROOT packages compound packages java compound packages script compound packages keyword cc packages and case suffix without det suffix the compound suffix class conj and packages suffix java script keyword packages and without the class suffix root ROOT packages compound packages java compound packages script compound packages keyword cc packages and case suffix without det suffix the compound suffix class conj and packages suffix public void get cases root ROOT get dobj get cases test suite root ROOT suite compound suite test suite class path ANTONYM ANTONYM create name ANTONYM ANTONYM full void ANTONYM ANTONYM name be ANTONYM ANTONYM;1
file NN helper NN functions NNS file helper functions root ROOT functions compound functions helper;1
override NN public int get VB attributes NNS int index NN override public int get attributes root ROOT get dobj get attributes int index;1
private static object NN set VBN length NN property NN context NN cx NN scriptable JJ target NN long length NN private static object set length property root ROOT set compound property length dobj set property context cx scriptable target long length;1
fast storage for dense arrays sparse arrays will use the superclass s fast storage for dense arrays sparse arrays will use the superclass s hashtable storage scheme private object NN dense JJ fast storage for dense arrays sparse arrays will use the superclass s root ROOT use amod storage fast nsubj use storage case arrays for amod arrays dense nmod for use arrays amod arrays sparse nsubj use arrays aux use will det s the amod s superclass dobj use s fast storage for dense arrays sparse arrays will use the superclass s root ROOT use amod storage fast nsubj use storage case arrays for amod arrays dense nmod for use arrays amod arrays sparse nsubj use arrays aux use will det s the amod s superclass dobj use s hashtable storage scheme root ROOT scheme amod scheme hashtable compound scheme storage private object dense dense sparse ANTONYM ANTONYM fast dense ANTONYM ANTONYM;1
public string NN get VB flags NNS public string get flags root ROOT get dobj get flags;1
static void to TO source NN impl NN string NN prefix NN string NN uri NN string NN builder NN sb NN static void to source impl root ROOT source mark source to dobj source impl string prefix string uri string builder root ROOT builder compound builder string sb;1
public boolean get VB param NN and CC var NN const NN public boolean get param and var const root ROOT get compound const param cc param and conj and param var compound const var dobj get const;1
second JJ formatted VBN in IN most RBS recent JJ invocation NN private long previous JJ seconds NNS Long MIN value NN second formatted in most recent invocation private long previous seconds root ROOT seconds amod seconds previous Long MIN value second min ANTONYM ANTONYM;1
unbinds the named object removes the terminal atomic name in name unbinds the named object removes the terminal atomic name in name from the target context that named by all but the terminal atomic part of name p this method is idempotent it succeeds even if the terminal atomic this method is idempotent it succeeds even if the terminal atomic name is not bound in the target context but throws name not found exception if any of the intermediate contexts do not exist param name the name to bind may not be empty exception name not found exception if an intermediate context does not exist exception naming exception if a naming exception is encountered override NN public void unbind NN name NN name NN throws naming VBG exception NN unbinds the named object removes the terminal atomic name in name root ROOT unbinds det object the amod object named nsubj removes object acl relcl unbinds removes det name the amod name terminal amod name atomic dobj removes name case name in nmod in removes name unbinds the named object removes the terminal atomic name in name root ROOT unbinds det object the amod object named nsubj removes object acl relcl unbinds removes det name the amod name terminal amod name atomic dobj removes name case name in nmod in removes name from the target context that named by all but the terminal atomic root ROOT context case context from det context the compound context target dep context that acl that named case all by nmod by named all cc all but det atomic the amod atomic terminal nmod by named atomic conj but all atomic part of name root ROOT part case name of nmod of part name p this method is idempotent it succeeds even if the terminal atomic root ROOT idempotent det method this nsubj idempotent method cop idempotent is nsubj succeeds it ccomp idempotent succeeds advmod atomic even mark atomic if det atomic the amod atomic terminal advcl if succeeds atomic this method is idempotent it succeeds even if the terminal atomic root ROOT idempotent det method this nsubj idempotent method cop idempotent is nsubj succeeds it ccomp idempotent succeeds advmod atomic even mark atomic if det atomic the amod atomic terminal advcl if succeeds atomic name is not bound in the target context but throws root ROOT bound nsubjpass bound name nsubj throws name auxpass bound is neg bound not case context in det context the compound context target nmod in bound context cc bound but conj but bound throws name not found exception if any of the intermediate contexts do not exist root ROOT found nsubj found name neg found not dobj found exception mark exist if nsubj exist any case contexts of det contexts the amod contexts intermediate nmod of any contexts aux exist do neg exist not advcl if found exist param name the name to bind may not be empty root ROOT empty compound name param dobj empty name det name the nsubj empty name mark bind to acl to name bind aux empty may neg empty not cop empty be exception name not found exception if an intermediate context does not root ROOT found compound name exception nsubj found name neg found not dobj found exception dep found if det context an amod context intermediate dep if context dep context does neg does not exist exception naming exception if a naming exception is encountered root ROOT exception compound exception exception compound exception naming mark encountered if det exception a amod exception naming nsubjpass encountered exception auxpass encountered is dep exception encountered override public void unbind name name throws naming exception root ROOT naming dobj naming exception all any ANTONYM ANTONYM all part ANTONYM ANTONYM be naming ANTONYM ANTONYM bind unbind ANTONYM ANTONYM bound even ANTONYM ANTONYM do naming ANTONYM ANTONYM does naming ANTONYM ANTONYM is naming ANTONYM ANTONYM is succeeds ANTONYM ANTONYM name be ANTONYM ANTONYM name do ANTONYM ANTONYM name does ANTONYM ANTONYM name is ANTONYM ANTONYM name throws ANTONYM ANTONYM named be ANTONYM ANTONYM named do ANTONYM ANTONYM named does ANTONYM ANTONYM named is ANTONYM ANTONYM named throws ANTONYM ANTONYM succeeds be ANTONYM ANTONYM terminal intermediate ANTONYM ANTONYM throws bind ANTONYM ANTONYM throws do ANTONYM ANTONYM throws does ANTONYM ANTONYM throws naming ANTONYM ANTONYM unbinds bind ANTONYM ANTONYM;1
boolean set VBN value NN object NN value NN scriptable JJ owner NN scriptable JJ start NN boolean set value root ROOT set dobj set value object value scriptable owner scriptable start;1
public int is VBZ valid JJ public int is valid root ROOT valid cop valid is;1
public dimension NN set VBN breadth NN dimension NN target NN int source NN public dimension set breadth root ROOT set dobj set breadth dimension target int source;1
public dimension NN set VBN length NN dimension NN target NN dimension NN source NN public dimension set length root ROOT set dobj set length dimension target dimension source;1
public dimension NN set VBN length NN dimension NN target NN int source NN public dimension set length root ROOT set dobj set length dimension target int source;1
public static object NN set VBN object NN index NN object NN obj NN double dbl NN index NN object NN value NN context NN cx NN public static object set object index root ROOT set compound index object dobj set index object obj double dbl index root ROOT index compound index dbl object value context cx;1
public list NN get VB expansion NN public list get expansion root ROOT get dobj get expansion;1
public void check NN collision NN string NN before IN string NN after IN public void check collision root ROOT collision compound collision check string before string after;1
protected void get VB method NN bodies NNS compilation NN unit NN declaration NN unit NN int place NN protected void get method bodies root ROOT get compound bodies method dobj get bodies compilation unit declaration root ROOT declaration compound declaration compilation compound declaration unit unit int place;1
public void is VBZ valid JJ object NN selection NN status NN info NN res NNS public void is valid root ROOT valid cop valid is object selection status info root ROOT info compound info status res;1
public void java NN to TO native JJ object NN object NN transfer NN data NNS transfer NN data NNS public void java to native root ROOT java case native to nmod to java native object object transfer data root ROOT data compound data transfer transfer data root ROOT data compound data transfer;1
public boolean get VB stats NNS public boolean get stats root ROOT get dobj get stats;1
saves the current enable disable state of the given control and its descendents in the returned object the controls are all disabled param w the control return an object capturing the enable disable state public static control NN enable VBP state NN disable VB control NN w NN saves the current enable disable state of the given control root ROOT saves det state the amod state current amod state enable amod state disable dobj saves state case control of det control the amod control given nmod of state control and its descendents in the returned object the controls root ROOT controls cc controls and nmod poss descendents its conj and controls descendents case object in det object the amod object returned nmod in descendents object det controls the are all disabled root ROOT disabled cop disabled are det disabled all param w the control root ROOT w nsubj w param det control the dobj w control return an object capturing the enable disable state root ROOT return det object an dobj return object acl object capturing det state the amod state enable amod state disable dobj capturing state public static control enable state root ROOT enable nsubj enable control dobj enable state disable control w enable disable ANTONYM ANTONYM enable disabled ANTONYM ANTONYM given control ANTONYM ANTONYM given controls ANTONYM ANTONYM saves return ANTONYM ANTONYM saves returned ANTONYM ANTONYM;1
returns true if this listener has a target for a back navigation only one listener needs to a back navigation only one listener needs to return true for the back button to be enabled public boolean is VBZ navigate VB forward RB enabled VBD returns true if this listener has a target for root ROOT returns amod returns true mark has if det listener this nsubj has listener advcl if true has det target a dobj has target acl target for a back navigation only one listener needs to root ROOT navigation det navigation a amod navigation back advmod one only nummod listener one nsubj needs listener acl relcl navigation needs nmod needs to a back navigation only one listener needs to root ROOT navigation det navigation a amod navigation back advmod one only nummod listener one nsubj needs listener acl relcl navigation needs nmod needs to return true for the back button to be enabled root ROOT return amod return true mark enabled for det button the amod button back nsubjpass enabled button mark enabled to auxpass enabled be advcl to true enabled public boolean is navigate forward enabled root ROOT navigate aux navigate is advmod navigate forward dep navigate enabled has needs ANTONYM ANTONYM has return ANTONYM ANTONYM returns has ANTONYM ANTONYM;1
vector NN target NN vector target;1
int is VBZ reached VBN int is reached root ROOT reached auxpass reached is;1
public byte get VB map VB context NN name NN public byte get map context name root ROOT map aux map get compound name context dobj map name;1
m NN association NN end NN start NN null JJ m association end root ROOT end compound end m compound end association start null;1
configuration default exclude pattern ie href action frame src ie href action frame src ie href action frame src public final static string NN include VBP name NN default NN href NN action NN frame NN src NN configuration default exclude pattern root ROOT exclude compound default configuration nsubj exclude default dobj exclude pattern ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame ie href action frame src root ROOT src compound src ie compound src href compound src action compound src frame public final static string include name default root ROOT include compound default name dobj include default href action frame src configuration frame ANTONYM ANTONYM configuration pattern ANTONYM ANTONYM exclude include ANTONYM ANTONYM frame name ANTONYM ANTONYM pattern frame ANTONYM ANTONYM pattern name ANTONYM ANTONYM;1
int references NNS int references;1
bool NN get VB sub JJ keys NNS c NN string NN list NN subkeys NNS returns NNS the DT list NN of IN sub NN keys NNS bool get sub keys root ROOT get amod keys sub dobj get keys c string list root ROOT list compound list c compound list string subkeys returns the list of sub keys list keys ANTONYM ANTONYM;1
public int get VB rows NNS public int get rows root ROOT get dobj get rows;1
private string NN types NNS private string types;1
public string NN get VB types NNS public string get types root ROOT get dobj get types;1
private double peak NN private double peak;1
private int nulls NNS private int nulls;1
public boolean get VB param NN and CC var NN const NN public boolean get param and var const root ROOT get compound const param cc param and conj and param var compound const var dobj get const;1
protected void check NN protected void check;1
protected void check NN expired VBD protected void check expired root ROOT expired nsubj expired check;1