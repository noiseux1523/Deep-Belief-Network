clear all memory in the pool and run all the cleanups this also destroys all clear all memory in the pool and run all the cleanups this also destroys all subpools param pool the pool to clear this does not actually free the memory it just allows the pool to re use this memory for the next allocation public static native void clear JJ long pool NN clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all clear all memory in the pool and run all the cleanups this also destroys all root ROOT clear det memory all dobj clear memory case pool in det pool the nmod in memory pool cc clear and conj and clear run det predet cleanups all det cleanups the dobj run cleanups nsubj destroys this advmod destroys also acl relcl cleanups destroys dep clear all subpools param pool the pool to clear root ROOT pool compound pool param det pool the dep pool pool case clear to nmod to pool clear this does not actually free the memory it just allows the pool root ROOT free nsubj free this aux free does neg free not advmod free actually det memory the dobj free memory nsubj allows it advmod allows just acl relcl memory allows det pool the dobj allows pool to re use this memory for the next allocation root ROOT re mark re to dobj re use det memory this dobj use memory case allocation for det allocation the amod allocation next nmod for use allocation public static native void clear long pool clear does ANTONYM ANTONYM clear free ANTONYM ANTONYM clear just ANTONYM ANTONYM clear run ANTONYM ANTONYM does use ANTONYM ANTONYM free allows ANTONYM ANTONYM free use ANTONYM ANTONYM public clear ANTONYM ANTONYM run does ANTONYM ANTONYM clear native SYNONYM SYNONYM in next SYNONYM SYNONYM
